var documenterSearchIndex = {"docs":
[{"location":"tutorial-nonfreqdims/#Non-frequency-dimensions","page":"Non-frequency dimensions","title":"Non-frequency dimensions","text":"","category":"section"},{"location":"ref-annotations/#NMR-Pulse-Programme-Semantic-Annotation-System","page":"Annotations","title":"NMR Pulse Programme Semantic Annotation System","text":"warning: Alpha Development Status\nThis annotation system is in early alpha development (currently v0.0.2). The schema, syntax, and functionality are subject to significant changes. Use with caution in production environments.","category":"section"},{"location":"ref-annotations/#Motivation","page":"Annotations","title":"Motivation","text":"Modern NMR pulse programmes are cryptic text files that encode complex experimental procedures, but they lack semantic information about what they actually measure. Analysis software must guess at the meaning of parameters like VALIST or VPLIST, leading to errors and requiring manual interpretation.\n\nThis annotation system embeds structured semantic metadata directly within pulse programme files as comments, enabling:\n\nAutomated Analysis: Software can automatically understand experimental structure\nReproducible Research: Clear provenance and citation information\nKnowledge Preservation: Experimental design captured alongside implementation\nCross-Platform Compatibility: Vendor-agnostic semantic layer\nCollaborative Development: Track contributors and development status\n\nnote: Current Implementation\nBasic annotation parsing is implemented in NMRTools.jl. The system is under active development with ongoing refinement of the schema and parsing capabilities.","category":"section"},{"location":"ref-annotations/#Design-Principles","page":"Annotations","title":"Design Principles","text":"","category":"section"},{"location":"ref-annotations/#Human-and-Machine-Readable","page":"Annotations","title":"Human and Machine Readable","text":"Annotations use simple comment syntax that NMR spectroscopists can read naturally whilst being structured enough for automated parsing.","category":"section"},{"location":"ref-annotations/#Embedded-and-Immutable","page":"Annotations","title":"Embedded and Immutable","text":"Metadata travels with the pulse programme file and cannot drift out of sync with the code.","category":"section"},{"location":"ref-annotations/#Modular-and-Extensible","page":"Annotations","title":"Modular and Extensible","text":"Experiments are described as combinations of core types and features, allowing new variations without redefining the entire taxonomy.","category":"section"},{"location":"ref-annotations/#Version-Controlled","page":"Annotations","title":"Version Controlled","text":"Both individual pulse programmes and the annotation system itself are versioned for reproducibility and compatibility.","category":"section"},{"location":"ref-annotations/#Annotation-Syntax","page":"Annotations","title":"Annotation Syntax","text":"","category":"section"},{"location":"ref-annotations/#Basic-Format","page":"Annotations","title":"Basic Format","text":"Annotations are extensions of Bruker comment lines, marked with ;@. Within these lines, annotations are written in YAML format. The initial ;@ will be stripped when parsing, permitting multi-line entries.\n\n;@ parameter: text value\n;@ parameter1: 0.123\n;@ parameter2: [list, of, items]\n;@ parameter3: {associative: array, key: value}\n;@ parameter4: |\n;@   This is\n;@   a multi-line\n;@   entry.","category":"section"},{"location":"ref-annotations/#Parameter-References","page":"Annotations","title":"Parameter References","text":"Parameter and list variable names are referenced directly without special syntax:\n\n;@ r1rho:\n;@   power: VALIST      # List variable\n;@   duration: VPLIST   # List variable  \n;@   offset: cnst28     # Constant parameter\n\nThe context distinguishes parameter names (letters) from literal values (numbers). NMRTools automatically resolves these references to actual values from the acqus file when loading data.","category":"section"},{"location":"ref-annotations/#Dimension-References","page":"Annotations","title":"Dimension References","text":"Dimensions use dotted path notation that references into experiment-specific parameter blocks:\n\n;@ dimensions: [r1rho.power, r1rho.duration, f1]\n;@ r1rho:\n;@   power: VALIST\n;@   duration: VPLIST\n\nThis creates an explicit connection: r1rho.power refers to the power field in the r1rho block, which is controlled by the VALIST parameter.","category":"section"},{"location":"ref-annotations/#Using-Annotations-in-NMRTools.jl","page":"Annotations","title":"Using Annotations in NMRTools.jl","text":"The complete annotation schema is defined in the pulse programmes repository. See the schema documentation and controlled vocabulary for details.\n\nIn NMRTools.jl, parsed annotation data is accessible via the :annotations metadata field or the annotations() convenience function.","category":"section"},{"location":"ref-annotations/#Accessing-annotation-data","page":"Annotations","title":"Accessing annotation data","text":"Annotations can be accessed using the annotations() function, which provides convenient nested access to annotation data. Dotted notation is automatically expanded:\n\n# Load a spectrum with annotations\nspec = loadnmr(\"path/to/annotated/experiment\")\n\n# Access all annotations\nall_annotations = annotations(spec)\n\n# Access specific annotation fields\nexperiment_type = annotations(spec, \"experiment_type\")\n\n# Access nested dictionary fields - these are equivalent:\nr1rho_duration = annotations(spec, \"r1rho\", \"duration\")\nr1rho_duration = annotations(spec, \"r1rho.duration\")\n\n# Access array elements by index\nfirst_dimension = annotations(spec, \"dimensions\", 1)\n\n# Deep nesting with dotted notation\ncalibration_start = annotations(spec, \"calibration.duration.start\")\n\nThe annotations() function accepts both string and symbol keys, and returns nothing if the requested field does not exist.","category":"section"},{"location":"ref-annotations/#Helper-Functions","page":"Annotations","title":"Helper Functions","text":"","category":"section"},{"location":"ref-annotations/#referencepulse(spec,-nucleus)","page":"Annotations","title":"referencepulse(spec, nucleus)","text":"Get the reference pulse calibration for a given nucleus:\n\n# Get 19F reference pulse (returns tuple of pulse length and power)\np1, pl1 = referencepulse(spec, \"19F\")\n\n# Get 1H reference pulse\np3, pl2 = referencepulse(spec, :1H)\n\nReturns nothing if no reference pulse is found for the specified nucleus.","category":"section"},{"location":"ref-annotations/#Example:-19F-R1ρ-on-resonance-experiment","page":"Annotations","title":"Example: 19F R1ρ on-resonance experiment","text":"This example experiment is annotated as follows (schema v0.0.2):\n\n;@ schema_version: \"0.0.2\"\n;@ sequence_version: \"0.1.0\"\n;@ title: 19F on-resonance R1rho relaxation dispersion\n;@ authors:\n;@   - Chris Waudby <c.waudby@ucl.ac.uk>\n;@   - Jan Overbeck\n;@ created: 2020-01-01\n;@ last_modified: 2025-11-15\n;@ repository: github.com/waudbygroup/pulseprograms\n;@ status: beta\n;@ experiment_type: [r1rho, 1d]\n;@ features: [on_resonance, temperature_compensation]\n;@ typical_nuclei: [19F, 1H]\n;@ citation:\n;@   - Overbeck (2020)\n;@ dimensions: [r1rho.power, r1rho.duration, f1]\n;@ acquisition_order: [f1, r1rho.duration, r1rho.power]\n;@ reference_pulse:\n;@   - {channel: f1, pulse: p1, power: pl1}\n;@   - {channel: f2, pulse: p3, power: pl2}\n;@ r1rho:\n;@   channel: f1\n;@   power: VALIST\n;@   duration: VPLIST\n;@   offset: 0\n;@   alignment: hard_pulse\n\nUsing annotated data, we can access the experiment metadata:\n\nusing NMRTools\n\n# Load the annotated experiment\nspec = loadnmr(\"path/to/experiment\")\n\n# Access experiment metadata\nannotations(spec, \"title\")           # \"19F on-resonance R1rho relaxation dispersion\"\nannotations(spec, \"experiment_type\") # [\"r1rho\", \"1d\"]\nannotations(spec, \"features\")        # [\"on_resonance\", \"temperature_compensation\"]\n\n# Access nested r1rho parameters (dotted notation works)\nannotations(spec, \"r1rho.power\")     # Vector of power values resolved from VALIST\nannotations(spec, \"r1rho.duration\")  # Vector of duration values resolved from VPLIST\nannotations(spec, \"r1rho\", \"channel\") # \"f1\"\nannotations(spec, \"r1rho\", \"offset\")  # 0 (on-resonance)\n\n# Access dimension information\nannotations(spec, \"dimensions\")       # [\"r1rho.power\", \"r1rho.duration\", \"f1\"]\nannotations(spec, \"dimensions\", 1)    # \"r1rho.power\"\n\n# Get reference pulse calibration\np1, pl1 = referencepulse(spec, \"19F\")","category":"section"},{"location":"ref-annotations/#Additional-Examples","page":"Annotations","title":"Additional Examples","text":"","category":"section"},{"location":"ref-annotations/#CEST-Experiment","page":"Annotations","title":"CEST Experiment","text":";@ schema_version: \"0.0.2\"\n;@ sequence_version: \"1.0.0\"\n;@ title: 19F CEST\n;@ experiment_type: [cest, 1d]\n;@ typical_nuclei: [19F]\n;@ dimensions: [cest.offset, f1]\n;@ acquisition_order: [f1, cest.offset]\n;@ reference_pulse:\n;@   - {channel: f1, pulse: p1, power: pl1}\n;@ cest:\n;@   channel: f1\n;@   power: pl8\n;@   duration: d18\n;@   offset: FQ1LIST","category":"section"},{"location":"ref-annotations/#Diffusion-Experiment","page":"Annotations","title":"Diffusion Experiment","text":";@ schema_version: \"0.0.2\"\n;@ sequence_version: \"2.0.1\"\n;@ title: 1H STE diffusion\n;@ experiment_type: [diffusion, 1d]\n;@ features: [ste, watergate]\n;@ typical_nuclei: [1H]\n;@ dimensions: [diffusion.gradient_strength, f1]\n;@ acquisition_order: [f1, diffusion.gradient_strength]\n;@ reference_pulse:\n;@   - {channel: f1, pulse: p1, power: pl1}\n;@ diffusion:\n;@   type: bipolar\n;@   coherence: [f1, 1]\n;@   big_delta: d20\n;@   little_delta: p31\n;@   tau: d17\n;@   gradient_strength: {type: linear, start: cnst1, end: cnst2, scale: gpz6}\n;@   gradient_shape: gpnam6","category":"section"},{"location":"ref-annotations/#Resources","page":"Annotations","title":"Resources","text":"Pulse Programme Repository\nSchema Documentation\nControlled Vocabulary (VOCABULARY.md)\nDecision Log - Design rationale and schema evolution","category":"section"},{"location":"metadata-fqlists/#Frequency-lists","page":"Frequency lists","title":"Frequency lists","text":"Frequency lists are used in NMR experiments to specify arrays of frequencies for selective excitation, CEST, or other variable-frequency experiments. On Bruker spectrometers, these are stored in files like fq1list through fq8list.\n\nNMRTools represents frequency lists as FQList structures that preserve encoding information (Hz vs ppm, relative vs absolute) and provide safe conversion functions.","category":"section"},{"location":"metadata-fqlists/#Accessing-frequency-lists","page":"Frequency lists","title":"Accessing frequency lists","text":"Frequency lists are automatically imported when loading data:\n\n# Load CEST experiment\nspec = loadnmr(\"path/to/cest/experiment\")\n\n# Get frequency list\nfqlist = acqus(spec, :fq1list)","category":"section"},{"location":"metadata-fqlists/#Extracting-frequency-values","page":"Frequency lists","title":"Extracting frequency values","text":"Use ppm() and hz() to safely extract frequency values. These functions handle all unit conversions automatically.","category":"section"},{"location":"metadata-fqlists/#Get-chemical-shifts-(in-ppm)","page":"Frequency lists","title":"Get chemical shifts (in ppm)","text":"dim = dims(spec, F2Dim)\nppm_values = ppm(fqlist, dim)","category":"section"},{"location":"metadata-fqlists/#Get-offsets-from-carrier-(in-Hz)","page":"Frequency lists","title":"Get offsets from carrier (in Hz)","text":"dim = dims(spec, F2Dim)\noffset_hz = hz(fqlist, dim)\n\ntip: Tip\nAlways use ppm() and hz() rather than accessing raw values directly. These functions handle all encoding schemes correctly.","category":"section"},{"location":"metadata-fqlists/#Creating-frequency-lists","page":"Frequency lists","title":"Creating frequency lists","text":"Construct FQList objects programmatically:\n\nusing NMRTools\n\n# Frequency list in Hz, relative to carrier\nfq_rel = FQList([100.0, 200.0, 300.0], :Hz, true)\n\n# Frequency list in ppm, absolute (chemical shifts)\nfq_abs = FQList([7.5, 8.0, 8.5], :ppm, false)","category":"section"},{"location":"ref-exceptions/#Exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"tutorial-phosphorylation/#2D-phosphorylation-kinetics","page":"2D phosphorylation kinetics","title":"2D phosphorylation kinetics","text":"","category":"section"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#Combining-NMR-experiments","page":"Utilities","title":"Combining NMR experiments","text":"sumexpts(INPUTFILES...; out=OUTPUT) is a utility function provided by NMRTools that allows you to combine multiple Bruker NMR experiments with optional weighting factors. The function accepts the following parameters:\n\nINPUTFILES...: One or more experiment numbers or paths to be combined\nout: The experiment number or path where the combined data will be stored (keyword argument)\n\nThe function works with both 1D experiments (using fid files) and multidimensional experiments (using ser files).","category":"section"},{"location":"utilities/#Basic-usage","page":"Utilities","title":"Basic usage","text":"The most common way to use sumexpts is with experiment numbers, which is the standard Bruker convention.\n\njulia> using NMRTools\n\njulia> cd(\"myexperiment\")\n\njulia> sumexpts(11, 12, out=999)\n=== NMR Experiment Summation ===\nOutput: 999\nInputs: 11, 12\nWeights: 1.0, 1.0\nCreated output experiment from 11\nData format: Float64 (little-endian)\nDetected nD experiment, using ser files\nCleaning processed data files in pdata/1...\n  Removed: 3rrr\nRemoved pdata/101 directory\nRemoved pdata/999 directory\nLoading 11/ser\nLoading 12/ser\nApplied weight 1.0 to experiment 11\nApplied weight 1.0 to experiment 12\nWriting output to 999/ser\nScans from 11: 8 × 1.0 = 8.0\nScans from 12: 16 × 1.0 = 16.0\nUpdated number of scans to 24\nUpdated title file with experiment summary\n=== Operation completed successfully ===\n\nThis creates a new experiment directory by copying experiment 11 as a template, then adding the raw data from all input experiments together. The result is stored in experiment 999.\n\nYou can also use full paths if your experiments are in different directories:\n\n# Combine experiments from a specific path\njulia> sumexpts(\"myexperiment/11\", \"myexperiment/12\", out=\"myexperiment/999\")\n# Output similar to above example","category":"section"},{"location":"utilities/#Adding-multiple-experiments","page":"Utilities","title":"Adding multiple experiments","text":"To combine more than two experiments, simply provide all experiment numbers:\n\n# Add three experiments together\njulia> cd(\"myexperiment\")\n\njulia> sumexpts(11, 12, 13, out=999)\n# Output shows all three experiments being combined\n\nBy default, all experiments are weighted equally. The result will be the sum of all input data.","category":"section"},{"location":"utilities/#Creating-difference-spectra","page":"Utilities","title":"Creating difference spectra","text":"To create a difference spectrum, use the weights parameter:\n\n# Create a difference spectrum (experiment 12 subtracted from experiment 11)\njulia> cd(\"myexperiment\")\n\njulia> sumexpts(11, 12, out=999, weights=[1.0, -1.0])\n=== NMR Experiment Summation ===\nOutput: 999\nInputs: 11, 12\nWeights: 1.0, -1.0\nCreated output experiment from 11\nData format: Float64 (little-endian)\nDetected nD experiment, using ser files\nCleaning processed data files in pdata/1...\n  Removed: 2rr\nLoading 11/ser\nLoading 12/ser\nApplied weight 1.0 to experiment 11\nApplied weight -1.0 to experiment 12\nWriting output to 999/ser\nScans from 11: 16 × 1.0 = 16.0\nScans from 12: 16 × 1.0 = 16.0\nUpdated number of scans to 32\nUpdated title file with experiment summary\n=== Operation completed successfully ===\n\nThis is particularly useful for applications like:\n\nReaction monitoring\nComparing before/after spectra\nHighlighting changes between samples\nRemoving background signals","category":"section"},{"location":"utilities/#Weighted-combinations","page":"Utilities","title":"Weighted combinations","text":"You can apply different weights to each experiment to create weighted averages or to emphasize certain spectra:\n\n# Weighted combination of three experiments\njulia> cd(\"myexperiment\")\n\njulia> sumexpts(11, 12, 13, out=999, weights=[0.5, 1.0, 2.0])\n=== NMR Experiment Summation ===\nOutput: 999\nInputs: 11, 12, 13\nWeights: 0.5, 1.0, 2.0\nCreated output experiment from 11\nData format: Float64 (little-endian)\nDetected nD experiment, using ser files\nCleaning processed data files in pdata/1...\nLoading 11/ser\nLoading 12/ser\nLoading 13/ser\nApplied weight 0.5 to experiment 11\nApplied weight 1.0 to experiment 12\nApplied weight 2.0 to experiment 13\nWriting output to 999/ser\nScans from 11: 8 × 0.5 = 4.0\nScans from 12: 16 × 1.0 = 16.0\nScans from 13: 32 × 2.0 = 64.0\nUpdated number of scans to 84\nUpdated title file with experiment summary\n=== Operation completed successfully ===\n\nThe weights vector must have the same length as the number of input experiments.","category":"section"},{"location":"utilities/#Experimental-details","page":"Utilities","title":"Experimental details","text":"The function handles several important details automatically:\n\nThe number of scans (NS parameter) in the output is updated to the weighted sum of input scan counts\nThe title file is updated to indicate which experiments were combined and their weights\nProcessed data files in pdata/1 are removed to prevent inconsistencies\nIf experiments have different data sizes, they are truncated to match the smallest dataset","category":"section"},{"location":"utilities/#Command-line-usage","page":"Utilities","title":"Command-line usage","text":"The function can also be called from the command line:\n\ncd myexperiment\njulia -e 'using NMRTools; sumexpts(11, 12, out=999)'\n\nOr for creating a difference spectrum:\n\ncd myexperiment\njulia -e 'using NMRTools; sumexpts(11, 12, out=999, weights=[1.0, -1.0])'\n\nThis allows for easy integration with processing workflows and shell scripts.","category":"section"},{"location":"tutorial-relaxation/#1D-relaxation-analysis","page":"1D relaxation analysis","title":"1D relaxation analysis","text":"Let's analyse a measurement of 1H T2 relaxation, acquired as a single pseudo-2D spectrum. First, we need to load the required packages. We will use LsqFit for the non-linear least squares fitting, Measurements to handle uncertainties, and Statistics for calculation of means and standard deviations.\n\nData have been processed in Topspin (using xf2), so can be loaded using the loadnmr function.\n\nusing NMRTools\nusing Plots\nusing LsqFit\nusing Measurements\nusing Statistics\n\nspec = exampledata(\"pseudo2D_T2\")\nnothing # hide","category":"section"},{"location":"tutorial-relaxation/#Set-up-parameters","page":"1D relaxation analysis","title":"Set up parameters","text":"The experiment uses a vclist to encode the relaxation time. The contents of this list are automatically parsed when the spectrum is loaded, and can be accessed with the acqus command:\n\nacqus(spec, :vclist)\n\nEach loop corresponds to a delay of 4 ms, so from this we can calculate a list of relaxation times. The spectrum we have just loaded has an UnknownDimension as the non-frequency dimension. We need to replace this with a TrelaxDimension that encodes the relaxation delays, and we can do this with the setrelaxtimes function:\n\nτ = acqus(spec, :vclist) * 4e-3\nspec = setrelaxtimes(spec, τ, \"s\")\nnothing # hide\n\nNext, we specify the chemical shift ranges used for plotting, fitting, and for determination of the noise level.\n\nplotrange = 0.7 .. 1.0 # ppm\ndatarange = 0.8 .. 0.9 # ppm\nnoiseposition = -2 # ppm\nnothing # hide","category":"section"},{"location":"tutorial-relaxation/#Plot-the-data","page":"1D relaxation analysis","title":"Plot the data","text":"To take a quick look at the data, we can plot the experiment either as 3D lines using the plot command, or as a heatmap:\n\nplot(\n    plot(spec[plotrange,:]),\n    heatmap(spec[plotrange,:])\n)\nsavefig(\"tutorial-relax-plot.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-relaxation/#Calculate-noise-and-peak-integrals","page":"1D relaxation analysis","title":"Calculate noise and peak integrals","text":"Now, we can determine the measurement noise, by taking the standard deviation of integrals across the different gradient points:\n\n# create a selector for the noise, matching the width of the data range\nnoisewidth = datarange.right - datarange.left\nnoiserange = (noiseposition-0.5noisewidth)..(noiseposition+0.5noisewidth)\n\n# integrate over the noise regions and take the standard deviation\n# (calculate the sum over the frequency dimension F1Dim, and use\n# `data` to convert from NMRData to a regular array)\nnoise = sum(spec[noiserange,:], dims=F1Dim) |> data |> std\n\n# calculate the integral of the data region similarly, using vec to convert to a list\nintegrals = sum(spec[datarange,:], dims=F1Dim) |> data |> vec\n\n# normalise noise and integrals by the maximum value\nnoise /= maximum(integrals)\nintegrals /= maximum(integrals)\nnothing # hide","category":"section"},{"location":"tutorial-relaxation/#Fitting","page":"1D relaxation analysis","title":"Fitting","text":"Now, we can fit the data to an exponential decay using the LsqFit package:\n\n# model parameters are (I0, R2)\nfunction model(t, p)\n    I0 = p[1]\n    R2 = p[2]\n    @. I0 * exp(-R2 * t)\nend\n\np0 = [1.0, 1.0] # rough guess of initial parameters\n\nfit = curve_fit(model, τ, integrals, p0) # run the fit\n\n# extract the fit parameters and standard errors\npfit = coef(fit)\nerr = stderror(fit)\nR2 = (pfit[2] ± err[2])\n\nSo we see that the fitted R₂ relaxation rate is 0.844 ± 0.016 s⁻¹","category":"section"},{"location":"tutorial-relaxation/#Plot-the-results","page":"1D relaxation analysis","title":"Plot the results","text":"Finally, plot the results:\n\n# calculate the best-fit curve across 100 points so it looks nice and smooth\nx = LinRange(0, maximum(τ)*1.1, 100)\nyfit = model(x, pfit)\n\np1 = scatter(τ, integrals .± noise, label=\"observed\",\n        frame=:box,\n        xlabel=\"Relaxation time (s)\",\n        ylabel=\"Integrated signal\",\n        title=\"\",\n        ylims=(0,Inf), # make sure y axis starts at zero\n        widen=true,\n        grid=nothing)\nplot!(p1, x, yfit, label=\"fit (R₂ = $R2 s⁻¹)\")\n\np2 = plot(spec[plotrange,1],linecolor=:black)\nplot!(p2, spec[datarange,1], fill=(0,:orange), linecolor=:red)\nhline!(p2, [0], c=:grey)\ntitle!(p2, \"\")\n\nplot(p1, p2, layout=(1,2))\nsavefig(\"tutorial-relax-fit.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"ref-io/#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"indexes/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexes/#NMRBase","page":"Index","title":"NMRBase","text":"Modules = [NMRTools.NMRBase]","category":"section"},{"location":"indexes/#NMRIO","page":"Index","title":"NMRIO","text":"Modules = [NMRTools.NMRIO]","category":"section"},{"location":"metadata-windows/#Window-functions","page":"Window functions","title":"Window functions","text":"Window functions (also called apodization functions) are applied to time-domain NMR data before Fourier transformation to modify the lineshape and signal-to-noise characteristics of the resulting spectrum. NMRTools automatically detects and stores the window function used during processing.","category":"section"},{"location":"metadata-windows/#Overview","page":"Window functions","title":"Overview","text":"Window functions are represented by subtypes of the abstract type WindowFunction. Each window function type stores:\n\nParameters specific to that window function\nThe acquisition time tmax (calculated after linear prediction but before zero filling)\n\nWindow functions are stored as axis metadata and can be accessed through the :window key:\n\nusing NMRTools\n\n# Load example spectrum\nspec = exampledata(\"2D_HN\")\n\n# Get the window function for a specific dimension\nwindow = spec[F2Dim, :window]","category":"section"},{"location":"metadata-windows/#Available-window-functions","page":"Window functions","title":"Available window functions","text":"","category":"section"},{"location":"metadata-windows/#No-apodization","page":"Window functions","title":"No apodization","text":"NullWindow(tmax)\n\nRepresents no apodization applied to the data. The multiplication factor is 1.0 for all time points.\n\nw = NullWindow(0.1)  # 0.1 second acquisition time","category":"section"},{"location":"metadata-windows/#Unknown-apodization","page":"Window functions","title":"Unknown apodization","text":"UnknownWindow(tmax)\n\nUsed when the window function cannot be determined from the processing parameters. This typically occurs with older data formats or non-standard processing.","category":"section"},{"location":"metadata-windows/#Exponential-(line-broadening)","page":"Window functions","title":"Exponential (line broadening)","text":"ExponentialWindow(lb, tmax)\n\nExponential apodization with line broadening lb in Hz. This is the most common apodization function in NMR processing.\n\nw(t) = exp(-pi cdot mathrmlb cdot t)\n\n# 5 Hz line broadening, 0.1 s acquisition\nw = ExponentialWindow(5.0, 0.1)\n\nEffect:\n\nPositive lb: Increases line broadening, improves S/N, reduces resolution\nNegative lb: Decreases line broadening (resolution enhancement), degrades S/N\nTypical values: 1-10 Hz for routine 1D proton spectra\n\nExample:\n\n# Get line broadening from a loaded spectrum\nlb = spec[F2Dim, :window]\nprintln(\"Line broadening: \", lb)","category":"section"},{"location":"metadata-windows/#Sine/Cosine-windows","page":"Window functions","title":"Sine/Cosine windows","text":"CosWindow(tmax)\n\nPure cosine (half-period) window function:\n\nw(t) = cosleft(fracpi t2t_mathrmmaxright)\n\nw = CosWindow(0.1)\n\nEffect: Commonly used for indirect dimensions in multidimensional NMR. Improves resolution with moderate S/N penalty.\n\n\n\nCos²Window(tmax)\n\nSquared cosine window function:\n\nw(t) = cos^2left(fracpi t2t_mathrmmaxright)\n\nw = Cos²Window(0.1)\n\nEffect: Gentler apodization than cosine, better S/N but slightly lower resolution.\n\n\n\nGeneralSineWindow(offset, endpoint, power, tmax)\n\nGeneral sine window function with adjustable parameters:\n\nw(t) = leftsinleft(\n    pi cdot mathrmoffset +\n    frac(mathrmendpoint - mathrmoffset)pi tt_mathrmmax\n    right)right^mathrmpower\n\nParameters:\n\noffset: Initial phase (0 to 1), determines starting value\nendpoint: Final phase (0 to 1), determines ending value\npower: Exponent applied to sine function\ntmax: Acquisition time\n\n# Typical shifted sine-bell\nw = GeneralSineWindow(0.5, 1.0, 2.0, 0.1)\n\nSpecial cases:\n\noffset=0.5, power=1.0 → CosWindow\noffset=0.5, power=2.0 → Cos²Window","category":"section"},{"location":"metadata-windows/#Gaussian-windows","page":"Window functions","title":"Gaussian windows","text":"LorentzToGaussWindow(expHz, gaussHz, tmax)\n\nLorentz-to-Gauss transformation, combining inverse exponential with Gaussian broadening:\n\nw(t) = exp(+pi cdot mathrmexpHz cdot t) cdot expleft(-frac(pi cdot mathrmgaussHz cdot t)^22right)\n\n# 5 Hz inverse exponential, 10 Hz Gaussian\nw = LorentzToGaussWindow(5.0, 10.0, 0.1)\n\nParameters:\n\nexpHz: Inverse exponential (line narrowing) in Hz\ngaussHz: Gaussian broadening in Hz\ntmax: Acquisition time\n\nEffect: Converts Lorentzian lineshapes (natural in NMR) to Gaussian lineshapes. Improves resolution for crowded spectra but requires careful parameter optimization.\n\n\n\nGeneralGaussWindow(expHz, gaussHz, center, tmax)\n\nGeneral Gaussian window with adjustable center position:\n\nw(t) = exp(+pi cdot mathrmexpHz cdot t) cdot\n       expleft(-frac(pi cdot mathrmgaussHz cdot (t - t_mathrmcenter))^22right)\n\nParameters:\n\nexpHz: Inverse exponential in Hz\ngaussHz: Gaussian broadening in Hz\ncenter: Position of Gaussian maximum (0 to 1)\ntmax: Acquisition time\n\n# Shifted Gaussian window\nw = GeneralGaussWindow(5.0, 10.0, 0.3, 0.1)\n\nWhen center = 0: Simplifies to LorentzToGaussWindow","category":"section"},{"location":"metadata-windows/#Working-with-window-functions","page":"Window functions","title":"Working with window functions","text":"","category":"section"},{"location":"metadata-windows/#Extracting-window-parameters","page":"Window functions","title":"Extracting window parameters","text":"Window function objects store their parameters as fields:\n\n# Load spectrum\nspec = exampledata(\"2D_HN\")\n\n# Get window for F2 dimension\nwin = spec[F2Dim, :window]\n\n# For ExponentialWindow\nif win isa ExponentialWindow\n    println(\"Line broadening: \", win.lb, \" Hz\")\n    println(\"Acquisition time: \", win.tmax, \" s\")\nend\n\n# For sine windows\nif win isa CosWindow\n    println(\"Acquisition time: \", win.tmax, \" s\")\nend","category":"section"},{"location":"metadata-windows/#Computing-the-apodization-function","page":"Window functions","title":"Computing the apodization function","text":"The apod function returns the time-domain apodization vector:\n\n# Load a spectrum\nspec = exampledata(\"2D_HN\")\n\n# Get apodization function for F2 dimension\napod_function = apod(spec, F2Dim)\n\nprintln(\"Apodization vector length: \", length(apod_function))\nprintln(\"First few values: \", apod_function[1:5])\n\nYou can also compute it directly from a dimension:\n\ndim = dims(spec, F2Dim)\napod_function = apod(dim)\n\nBy default, the apodization vector is zero-filled to match tdzf. To get only the acquired points:\n\napod_function = apod(spec, F2Dim, false)  # zerofill=false","category":"section"},{"location":"metadata-windows/#Simulating-lineshapes","page":"Window functions","title":"Simulating lineshapes","text":"The lineshape function generates a simulated spectrum including the effect of the window function:\n\n# Get the F2 axis\naxis = dims(spec, F2Dim)\n\n# Simulate a peak at 8.5 ppm with R2 = 10 s-1\nchemical_shift = 8.5  # ppm\nR2 = 10.0            # s-1\nsimulated = lineshape(axis, chemical_shift, R2)\n\nprintln(\"Simulated lineshape length: \", length(simulated))\n\nThis is useful for:\n\nFitting experimental peaks\nUnderstanding window function effects\nQuality control and validation\n\nYou can also request complex-valued lineshapes:\n\n# Get complex lineshape\nsimulated_complex = lineshape(axis, chemical_shift, R2, ComplexLineshape())","category":"section"},{"location":"tutorial-animation/#Animating-spectra","page":"Animating spectra","title":"Animating spectra","text":"The plot recipes defined within NMRTools provide an easy way to generate animations of spectral data, using the @animate macro defined within the Plots package. A couple of examples are provided below.","category":"section"},{"location":"tutorial-animation/#Phosphorylation-kinetics","page":"Animating spectra","title":"Phosphorylation kinetics","text":"First, load in some data. This pseudo-3D kinetic data - a series of 1H,15N SOFAST-HMQC spectra - showing the progressive phosphorylation of cJun by JNK1 kinase. Read more about the paper here: Waudby et al. Nat Commun (2022).\n\nusing NMRTools, Plots\n\nspec=exampledata(\"pseudo3D_kinetics\")\nnothing # hide\n\nThe data have been processed in Topspin using ftnd 3 and ftnd 2, so that the final dimension of the 3D represents the phosphorylation time. Each 2D plane took 2 minutes to acquire, and there was an initial delay of 4 min between adding the kinase and recording the first free induction decay. We need to calculate a list of times from this information, that we can use to label the animation:\n\n# get number of time points\nnt = size(spec,3)\n\n# calculate a list of measurement times\n# experiment was recorded with 2 min per spectrum, plus initial dead-time of 4 min\ntmin = LinRange(0, 2*(nt-1), nt) .+ 4\nthr = tmin / 60\n\nNow we can generate the animation, by looping over each point in the time series with the Plots @animate macro, then saving as an animated gif.\n\nanim = @animate for i=1:nt\n    # generate a nice title with the time rounded to 1 decimal place, e.g. \"Time elapsed: 0.1 hr\"\n    titletext = \"Time elapsed: $(round(thr[i],digits=1)) hr\"\n    plot(spec[:,:,i], title=titletext)\nend\n\n# save as an animated gif\ngif(anim, \"kinetics.gif\", fps=30)\nnothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-animation/#2D-titration","page":"Animating spectra","title":"2D titration","text":"First, load in some data - as described in the tutorial on plotting.\n\nspectra2d = exampledata(\"2D_HN_titration\")\nnothing # hide\n\nNow loop over the spectra to produce the animation:\n\nrefspec = spectra2d[1]\nanim=@animate for spec in spectra2d\n    plot(spec, xlims=(6,10.5), title=label(spec), normalize=refspec)\nend\n\ngif(anim, \"titration.gif\", fps=8)\nnothing # hide\n\n(Image: )\n\nnote: Note\nThe normalize=refspec parameter scales all spectra relative to the reference spectrum, defined on the first line as the first spectrum in the titration series. This ensures that contour levels are directly comparable across the different spectra. This normalization automatically compensates for differences in acquisition parameters such as number of scans and receiver gain that would otherwise affect absolute intensities.","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#NMRBase","page":"API","title":"NMRBase","text":"","category":"section"},{"location":"api/#NMRIO","page":"API","title":"NMRIO","text":"","category":"section"},{"location":"api/#NMRTools.NMRBase.AbstractNMRData","page":"API","title":"NMRTools.NMRBase.AbstractNMRData","text":"AbstractNMRData <: DimensionalData.AbstractDimArray\n\nAbstract supertype for objects that wrap an array of NMR data, and metadata about its contents.\n\nAbstractNMRDatas inherit from AbstractDimArray from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl Dimensions.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.Coherence","page":"API","title":"NMRTools.NMRBase.Coherence","text":"Coherence\n\nAbstract supertype for representing coherences.\n\nSee also SQ, MQ.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.ComplexLineshape","page":"API","title":"NMRTools.NMRBase.ComplexLineshape","text":"ComplexLineshape\n\nReturn a complex-valued lineshape when used in calculations\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.CosWindow","page":"API","title":"NMRTools.NMRBase.CosWindow","text":"CosWindow(tmax)\n\nApodization by a pure cosine function. Acquisition time is tmax.\n\nSee also Cos²Window, SineWindow.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.Cos²Window","page":"API","title":"NMRTools.NMRBase.Cos²Window","text":"Cos²Window(tmax)\n\nApodization by a pure cosine squared function. Acquisition time is tmax.\n\nSee also CosWindow, SineWindow.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.ExponentialWindow","page":"API","title":"NMRTools.NMRBase.ExponentialWindow","text":"ExponentialWindow(lb, tmax)\n\nExponential window function, with a line broadening of lb Hz. Acquisition time is tmax.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.FrequencyDimension","page":"API","title":"NMRTools.NMRBase.FrequencyDimension","text":"FrequencyDimension <: NMRDimension\n\nAbstract supertype for frequency dimensions used in NMRData objects. Concrete types F1Dim, F2Dim, F3Dim and F4Dim are generated for use in creating objects.\n\nSee also NonFrequencyDimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.GaussWindow","page":"API","title":"NMRTools.NMRBase.GaussWindow","text":"GaussWindow(expHz, gaussHz, center, tmax)\n\nAbstract representation of Lorentz-to-Gauss window functions, applying an inverse exponential of expHz Hz, and a gaussian broadening of gaussHz Hz, with maximum at center (between 0 and 1). Acquisition time is tmax.\n\nSpecialises to LorentzToGaussWindow when center is zero, otherwise GeneralGaussWindow.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.GradientDimension","page":"API","title":"NMRTools.NMRBase.GradientDimension","text":"GradientDimension <: NonFrequencyDimension <: NMRDimension\n\nAbstract supertype for gradient-encoded dimensions used in NMRData objects. Concrete types G1Dim, G2Dim, G3Dim and G4Dim are generated for use in creating objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.HasNonFrequencyDimension","page":"API","title":"NMRTools.NMRBase.HasNonFrequencyDimension","text":"@traitdef HasNonFrequencyDimension{D}\n\nA trait indicating whether the data object has a non-frequency domain dimension.\n\nExample\n\n@traitfn f(x::X) where {X; HasNonFrequencyDimension{X}} = \"This spectrum has a non-frequency domain dimension!\"\n@traitfn f(x::X) where {X; SimpleTraits.Not{HasNonFrequencyDimension{X}}} = \"This is a pure frequency-domain spectrum!\"\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.LineshapeComplexity","page":"API","title":"NMRTools.NMRBase.LineshapeComplexity","text":"LineshapeComplexity\n\nAbstract type to specify calculation of RealLineshape or ComplexLineshape in function calls.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.MQ","page":"API","title":"NMRTools.NMRBase.MQ","text":"MQ(coherences, label==\"\")\n\nRepresentation of a multiple-quantum coherence. Coherences are specified as a tuple of tuples, of the form (nucleus, coherenceorder)\n\nExamples\n\njulia> MQ(((H1,1), (C13,-1)), \"ZQ\")\nMQ(((H1, 1), (C13, -1)), \"ZQ\")\n\njulia> MQ(((H1,3), (C13,1)), \"QQ\")\nMQ(((H1, 3), (C13, 1)), \"QQ\")\n\nSee also Nucleus, SQ.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.NMRData","page":"API","title":"NMRTools.NMRBase.NMRData","text":"NMRData <: AbstractNMRData\nNMRData(A::AbstractArray{T,N}, dims; kw...)\nNMRData(A::AbstractNMRData; kw...)\n\nA generic AbstractNMRData for NMR array data. It holds memory-backed arrays.\n\nKeywords\n\ndims: Tuple of NMRDimensions for the array.\nname: Symbol name for the array, which will also retreive named layers if NMRData   is used on a multi-layered file like a NetCDF.\nmissingval: value representing missing data, normally detected from the file. Set manually   when you know the value is not specified or is incorrect. This will not change any   values in the NMRData, it simply assigns which value is treated as missing.\n\nInternal Keywords\n\nIn some cases it is possible to set these keywords as well.\n\ndata: can replace the data in an AbstractNMRData\nrefdims: Tuple of position Dimensions the array was sliced from, defaulting to ().\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.NMRDimension","page":"API","title":"NMRTools.NMRBase.NMRDimension","text":"NMRDimension\n\nAbstract supertype for all axes used in NMRData objects.\n\nSee also FrequencyDimension and NonFrequencyDimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.NMRToolsError","page":"API","title":"NMRTools.NMRBase.NMRToolsError","text":"NMRToolsError(message)\n\nAn error arising in NMRTools.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.NonFrequencyDimension","page":"API","title":"NMRTools.NMRBase.NonFrequencyDimension","text":"NonFrequencyDimension <: NMRDimension\n\nAbstract supertype for non-frequency dimensions used in NMRData objects. Sub-types include TimeDimension, GradientDimension,  and UnknownDimension.\n\nSee also FrequencyDimension.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.Nucleus","page":"API","title":"NMRTools.NMRBase.Nucleus","text":"Nucleus\n\nEnumeration of common nuclei associated with biomolecular NMR. Nuclei are named e.g. H1, C13.\n\nDefined nuclei: H1, H2, C12, C13, N14, N15, F19, P31.\n\nSee also spin, gyromagneticratio, Coherence.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.NullWindow","page":"API","title":"NMRTools.NMRBase.NullWindow","text":"NullWindow(tmax)\n\nNo apodization applied. Acquisition time is tmax.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.Power","page":"API","title":"NMRTools.NMRBase.Power","text":"Power{T}\n\nA type to represent NMR pulse powers that can be described either in Watts (W) or as dB attenuation (dB). Internally stores the dB value as type T.\n\nConstructors\n\nPower(value, :dB) - Create from dB attenuation value\nPower(value, :W) - Create from Watts value\n\nGetters\n\ndb(p::Power) - Get dB attenuation value\nwatts(p::Power) - Get Watts value\n\nExamples\n\n# Create power from dB attenuation\np1 = Power(30.0, :dB)\ndb(p1)    # 30.0\nwatts(p1) # 0.001\n\n# Create power from Watts\np2 = Power(0.5, :W)\nwatts(p2) # 0.5\ndb(p2)    # ≈ 3.01\n\n# Works with integers and other numeric types\np3 = Power(10, :W)\ndb(p3)    # -10.0\n\n# Zero watts is represented as 120 dB attenuation\np4 = Power(0.0, :W)\ndb(p4)    # 120.0\n\nConversion\n\nConverting W to dB: -10 * log10(plW) Converting dB to W: 10^(-dB/10)\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.RealLineshape","page":"API","title":"NMRTools.NMRBase.RealLineshape","text":"RealLineshape\n\nReturn a real-valued lineshape when used in calculations\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.SQ","page":"API","title":"NMRTools.NMRBase.SQ","text":"SQ(nucleus::Nucleus, label==\"\")\n\nRepresentation of a single quantum coherence on a given nucleus.\n\nSee also Nucleus, MQ.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.SineWindow","page":"API","title":"NMRTools.NMRBase.SineWindow","text":"SineWindow(offset, endpoint, power, tmax)\n\nAbstract window function representing multiplication by sine/cosine functions. Acquisition time is tmax.\n\nleftsinleft(\n    picdotmathrmoffset +\n    fracleft(mathrmend - mathrmoffsetright)pi tmathrmtmax\n    right)right^mathrmpower\n\nSpecialises to CosWindow, Cos²Window or GeneralSineWindow.\n\nArguments\n\noffset: initial value is sin(mathrmoffsetcdotpi) (0 to 1)\nendpoint: initial value is sin(mathrmendpointcdotpi) (0 to 1)\npow: sine exponent\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.TimeDimension","page":"API","title":"NMRTools.NMRBase.TimeDimension","text":"TimeDimension <: NonFrequencyDimension <: NMRDimension\n\nAbstract supertype for time dimensions used in NMRData objects. Concrete types T1Dim, T2Dim, T3Dim and T4Dim are generated for time-domains representing frequency evolution, and TrelaxDim and TkinDim are generated for representing relaxation and real-time kinetics.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.UnknownDimension","page":"API","title":"NMRTools.NMRBase.UnknownDimension","text":"UnknownDimension <: NonFrequencyDimension <: NMRDimension\n\nAbstract supertype for unknown, non-frequency dimensions used in NMRData objects. Concrete types X1Dim, X2Dim, X3Dim and X4Dim are generated for use in creating objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.UnknownWindow","page":"API","title":"NMRTools.NMRBase.UnknownWindow","text":"UnknownWindow(tmax)\n\nUnknown apodization applied. Acquisition time is tmax.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.WindowFunction","page":"API","title":"NMRTools.NMRBase.WindowFunction","text":"WindowFunction\n\nAbstract type to represent apodization functions.\n\nWindow functions are represented by subtypes of the abstract type WindowFunction, each of which contain appropriate parameters to specify the particular function applied. In addition, the acquisition time tmax is also stored (calculated at the point the window function is applied, i.e. after linear prediction but before zero filling).\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.stack-Union{Tuple{Vector{D}}, Tuple{D}, Tuple{N}, Tuple{T}} where {T, N, D<:(AbstractNMRData{T, N})}","page":"API","title":"Base.stack","text":"stack(expts::Vector{NMRData})\n\nCombine a collection of equally-sized NMRData into one larger array, by arranging them along a new dimension, of type UnknownDimension.\n\nThrows a DimensionMismatch if data are not of compatible shapes.\n\n\n\n\n\n","category":"method"},{"location":"api/#DimensionalData.Dimensions.Lookups.metadata","page":"API","title":"DimensionalData.Dimensions.Lookups.metadata","text":"metadata(nmrdata, key)\nmetadata(nmrdata, dim, key)\nmetadata(nmrdimension, key)\n\nReturn the metadata for specified key, or nothing if not found. Keys are passed as symbols.\n\nExamples (spectrum metadata)\n\n:ns: number of scans\n:ds: number of dummy scans\n:rg: receiver gain\n:ndim: number of dimensions\n:title: spectrum title (contents of title pdata file)\n:filename: spectrum filename\n:pulseprogram: title of pulse program used for acquisition\n:experimentfolder: path to experiment\n:noise: RMS noise level\n\nExamples (dimension metadata)\n\n:pseudodim: flag indicating non-frequency domain data\n:npoints: final number of (real) data points in dimension (after extraction)\n:td: number of complex points acquired\n:tdzf: number of complex points when FT executed, including LP and ZF\n:bf: base frequency, in Hz\n:sf: carrier frequency, in Hz\n:offsethz: carrier offset from bf, in Hz\n:offsetppm: carrier offset from bf, in ppm\n:swhz: spectrum width, in Hz\n:swppm: spectrum width, in ppm\n:region: extracted region, expressed as a range in points, otherwise missing\n:window: WindowFunction indicating applied apodization\n:referenceoffset: referencing (in ppm) applied to the dimension\n\nSee also estimatenoise!.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.Lookups.units","page":"API","title":"DimensionalData.Dimensions.Lookups.units","text":"units(nmrdata)\nunits(nmrdata, dim)\nunits(nmrdimension)\n\nReturn the physical units associated with an NMRData structure or an NMRDimension.\n\n\n\n\n\n","category":"function"},{"location":"api/#DimensionalData.Dimensions.label","page":"API","title":"DimensionalData.Dimensions.label","text":"label(nmrdata)\nlabel(nmrdata, dim)\nlabel(nmrdimension)\n\nReturn a short label associated with an NMRData structure or an NMRDimension. By default, for a spectrum this is obtained from the first line of the title file. For a frequency dimension, this is normally something of the form 1H chemical shift (ppm).\n\nSee also label!.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase._lineshape","page":"API","title":"NMRTools.NMRBase._lineshape","text":"_lineshape(ω, R2, ωaxis, window, complexity)\n\nInternal function to calculate a resonance lineshape with frequency ω and relaxation rate R2, calculated at frequencies ωaxis and with apodization according to the specified window function.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.acqus-Tuple{AbstractNMRData}","page":"API","title":"NMRTools.NMRBase.acqus","text":"acqus(nmrdata)\nacqus(nmrdata, key)\nacqus(nmrdata, key, index)\n\nReturn data from a Bruker acqus file, or nothing if it does not exist. Keys can be passed as symbols or strings. If no key is specified, a dictionary is returned representing the entire acqus file.\n\nIf present, the contents of auxilliary files such as vclist and vdlist can be accessed using this function.\n\nExamples\n\njulia> acqus(expt, :pulprog)\n\"zgesgp\"\njulia> acqus(expt, \"TE\")\n276.9988\njulia> acqus(expt, :p, 1)\n9.2\njulia> acqus(expt, \"D\", 1)\n0.1\njulia> acqus(expt, :vclist)\n11-element Vector{Int64}:\n[...]\n\nSee also metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.annotations-Tuple{AbstractNMRData}","page":"API","title":"NMRTools.NMRBase.annotations","text":"annotations(nmrdata)\nannotations(nmrdata, key)\nannotations(nmrdata, key, index)\nannotations(nmrdata, key1, key2)\nannotations(nmrdata, keys...)\n\nReturn annotation data from pulse programme, or nothing if it does not exist. Keys can be passed as strings or symbols. If no key is specified, the entire annotations dictionary is returned.\n\nDotted names are automatically split and dereferenced, e.g. annotations(spec, \"cest.duration\") is equivalent to annotations(spec, \"cest\", \"duration\").\n\nThis function provides nested access to annotations stored in metadata[:annotations]. Multiple keys can be chained to access nested dictionaries or specific array elements.\n\nExamples\n\njulia> annotations(spec, \"title\")\n\"19F CEST\"\n\njulia> annotations(spec, \"dimensions\")\n2-element Vector{String}:\n \"cest.offset\"\n \"f1\"\n\njulia> annotations(spec, \"dimensions\", 1)\n\"cest.offset\"\n\njulia> annotations(spec, \"cest\", \"duration\")\n0.5\n\njulia> annotations(spec, \"cest.duration\")\n0.5\n\njulia> annotations(spec, :reference_pulse)\n1-element Vector{Dict{String, Any}}:\n Dict(\"channel\" => \"f1\", \"pulse\" => 9.2e-6, \"power\" => -3.0)\n\njulia> annotations(spec, \"calibration.duration.start\")\n0.001\n\nSee also metadata, acqus.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.apod","page":"API","title":"NMRTools.NMRBase.apod","text":"apod(spec::NMRData, dimension, zerofill=true)\n\nReturn the time-domain apodization function for the specified axis, as a vector of values.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.coherenceorder","page":"API","title":"NMRTools.NMRBase.coherenceorder","text":"coherenceorder(coherence)\n\nCalculate the total coherence order.\n\nExamples\n\njulia> coherenceorder(SQ(H1))\n1\n\njulia> coherenceorder(MQ(((H1,1),(C13,1))))\n2\n\njulia> coherenceorder(MQ(((H1,1),(C13,-1))))\n0\n\njulia> coherenceorder(MQ(((H1,3),(C13,1))))\n4\n\njulia> coherenceorder(MQ(((H1,0),)))\n0\n\nSee also Nucleus, SQ, MQ.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.data-Tuple{NMRData, Any}","page":"API","title":"NMRTools.NMRBase.data","text":"data(nmrdata, dim)\n\nReturn the numerical data associated with the specified dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.data-Tuple{NMRData}","page":"API","title":"NMRTools.NMRBase.data","text":"data(nmrdata)\n\nReturn the numerical data associated with the specified NMRData.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.data-Tuple{NMRDimension}","page":"API","title":"NMRTools.NMRBase.data","text":"data(nmrdimension)\n\nReturn the numerical data associated with an NMR dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.db-Tuple{Power}","page":"API","title":"NMRTools.NMRBase.db","text":"db(p::Power)\n\nGet the power level in dB attenuation.\n\nExample\n\np = Power(20.0, :dB)\ndb(p)  # 20.0\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.decimate","page":"API","title":"NMRTools.NMRBase.decimate","text":"decimate(data, n dims=1)\n\nDecimate NMR data into n-point averages along the specified dimension. Note that data are averaged and not summed. Noise metadata is not updated.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.estimatenoise!-Tuple{NMRData}","page":"API","title":"NMRTools.NMRBase.estimatenoise!","text":"estimatenoise!(nmrdata)\n\nEstimate the rms noise level in the data and update :noise metadata.\n\nIf called on an Array of data, each item will be updated.\n\nAlgorithm\n\nData are sorted into numerical order, and the highest and lowest 12.5% of data are discarded (so that 75% of the data remain). These values are then fitted to a truncated gaussian distribution via maximum likelihood analysis.\n\nThe log-likelihood function is:\n\nlog L(mu sigma) = sum_ilog P(y_i mu sigma)\n\nwhere the likelihood of an individual data point is:\n\nlog P(ymusigma) =\n    logfrac\n        phileft(fracx-musigmaright)\n    \n        sigma cdot leftPhileft(fracb-musigmaright) -\n            Phileft(fraca-musigmaright)right\n\nand phi(x) and Phi(x) are the standard normal pdf and cdf functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.gyromagneticratio","page":"API","title":"NMRTools.NMRBase.gyromagneticratio","text":"gyromagneticratio(n::Nucleus)\ngyromagneticratio(c::Coherence)\n\nReturn the gyromagnetic ratio in Hz/T of a nucleus, or calculate the effective gyromagnetic ratio of a coherence. This is equal to the product of the individual gyromagnetic ratios with their coherence orders.\n\nReturns nothing if not defined.\n\nExamples\n\njulia> gyromagneticratio(H1)\n2.6752218744e8\n\njulia> gyromagneticratio(SQ(H1))\n2.6752218744e8\n\njulia> gyromagneticratio(MQ(((H1,1),(C13,1))))\n3.3480498744e8\n\njulia> gyromagneticratio(MQ(((H1,0),)))\n0.0\n\nSee also Nucleus, Coherence.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.hasannotations-Tuple{Any}","page":"API","title":"NMRTools.NMRBase.hasannotations","text":"hasannotations(nmrdata) -> Bool\n\nCheck if the NMRData object has any annotations.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.hasnonfrequencydimension-Union{Tuple{NMRData{T, N, A, R, A1} where {R<:Tuple, A1<:AbstractArray{T, N}}}, Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A}","page":"API","title":"NMRTools.NMRBase.hasnonfrequencydimension","text":"hasnonfrequencydimension(spectrum)\n\nReturn true if the spectrum contains a non-frequency domain dimension.\n\nExample\n\njulia> y2=loadnmr(\"exampledata/2D_HN/test.ft2\");\njulia> hasnonfrequencydimension(y2)\nfalse\njulia> y3=loadnmr(\"exampledata/pseudo3D_HN_R2/ft/test%03d.ft2\");\njulia> hasnonfrequencydimension(y3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.hz-Tuple{FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.hz","text":"hz(axis)\n\nReturn the offsets (in Hz) for points along a frequency axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.hz-Tuple{Power, Power, Any, Any}","page":"API","title":"NMRTools.NMRBase.hz","text":"hz(p::Power, ref_p::Power, ref_pulselength, ref_pulseangle_deg)\n\nConvert power to radiofrequency strength in Hz using reference pulse parameters.\n\nArguments\n\np::Power: Power to convert\nref_p::Power: Reference power\nref_pulselength: Reference pulse length in microseconds\nref_pulseangle_deg: Reference pulse flip angle in degrees\n\nReturns\n\nRadiofrequency strength in Hz for power p\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.hz-Tuple{Power, Power, Any}","page":"API","title":"NMRTools.NMRBase.hz","text":"hz(p::Power, ref_p::Power, ref_Hz)\n\nConvert power to radiofrequency strength in Hz using a reference power and known Hz value.\n\nUses the relationship: Hz = ref_Hz * 10^(-ΔdB/20) where ΔdB is the power difference.\n\nArguments\n\np::Power: Power to convert\nref_p::Power: Reference power with known Hz value\nref_Hz: Radiofrequency strength in Hz at the reference power\n\nReturns\n\nRadiofrequency strength in Hz for power p\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.hz-Tuple{Union{Number, AbstractArray{<:Number}}, FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.hz","text":"hz(δ, axis)\n\nReturn the offset (in Hz) for a chemical shift (or list of shifts) on a frequency axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.label!","page":"API","title":"NMRTools.NMRBase.label!","text":"label!(nmrdata, labeltext)\nlabel!(nmrdata, dim, labeltext)\nlabel!(nmrdimension, labeltext)\n\nSet the label associated with an NMRData structure or an NMRDimension.\n\nSee also label.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.lineshape-Tuple{Any, Any, Any, LineshapeComplexity}","page":"API","title":"NMRTools.NMRBase.lineshape","text":"lineshape(axis, δ, R2, complexity=RealLineshape())\n\nReturn a simulated real- or complex-valued spectrum for a resonance with chemical shift δ and relaxation rate R2, using the parameters and window function associated with the specified axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.missingval","page":"API","title":"NMRTools.NMRBase.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRBase.nucleus-Tuple{AbstractString}","page":"API","title":"NMRTools.NMRBase.nucleus","text":"nucleus(label::AbstractString) -> Nucleus\n\nParse a nucleus from a string label, returning the corresponding Nucleus enum value.\n\nThe function accepts common NMR nucleus notation formats:\n\nMass number followed by element symbol: \"1H\", \"13C\", \"15N\", \"19F\", \"31P\"\nElement symbol followed by mass number: \"H1\", \"C13\", \"N15\", \"F19\", \"P31\"\n\nExamples\n\nnucleus(\"19F\")  # returns F19\nnucleus(\"1H\")   # returns H1\nnucleus(\"13C\")  # returns C13\nnucleus(\"15N\")  # returns N15\n\nThrows ArgumentError if the nucleus is not recognised or not defined in the Nucleus enum.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.pcls-Tuple{AbstractMatrix, AbstractVector}","page":"API","title":"NMRTools.NMRBase.pcls","text":"pcls(A, y)\n\nCompute the phase-constrained least squares solution:\n\ny = A x e^iphi\n\nfollowing the algorithm of Bydder (2010) Lin Alg & Apps.\n\nReturns the tuple (x, ϕ), containing the component amplitudes and global phase.\n\nIf passed a matrix Y, the function will return a matrix of component amplitudes and a list of global phases corresponding to each row.\n\nArguments\n\nA: (m,n) complex matrix with component spectra\ny: (m,) complex vector containing the observed spectrum\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.ppm-Tuple{FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.ppm","text":"ppm(axis)\n\nReturn the ppm values for points along a frequency axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.ppm-Tuple{Union{Number, AbstractArray{<:Number}}, FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.ppm","text":"ppm(offset, axis)\n\nReturn the chemical shifts for a given offset or list of offsets along a frequency axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.referencepulse-Tuple{AbstractNMRData, Any}","page":"API","title":"NMRTools.NMRBase.referencepulse","text":"referencepulse(spec, nucleus) -> (pulse_length, power)\n\nGet the reference pulse calibration for a given nucleus from pulse programme annotations. Returns a tuple of (pulse_length, power) or nothing if not found.\n\nThe reference pulse is the calibrated 90° hard pulse used as the basis for all power  calculations on that channel.\n\nArguments\n\nspec: NMRData object with annotations\nnucleus: Nucleus symbol or string (e.g., :19F, \"19F\", :1H, \"1H\")\n\nReturns\n\n(pulse_length, power): Tuple where pulse_length is in μs and power is a Power object\nnothing: If no reference pulse found for the specified nucleus\n\nExamples\n\njulia> referencepulse(spec, \"19F\")\n(13.29, Power(-9.03 dB, 8.0 W))\n\njulia> referencepulse(spec, :1H)\n(9.2, Power(-3.0 dB, 32.0 W))\n\nSee also annotations.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.replacedimension-Tuple{NMRData, Any, Any}","page":"API","title":"NMRTools.NMRBase.replacedimension","text":"replacedimension(nmrdata, olddimnumber, newdim)\n\nReturn a new NMRData, in which the numbered axis is replaced by a new Dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.scale-Tuple{AbstractNMRData}","page":"API","title":"NMRTools.NMRBase.scale","text":"scale(d::AbstractNMRData)\n\nReturn a scaling factor for the data combining the number of scans, receiver gain, and, if specified, the sample concentration.\n\nmathrmscale = mathrmns cdot mathrmrg cdot mathrmconc\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.setgradientlist-Tuple{}","page":"API","title":"NMRTools.NMRBase.setgradientlist","text":"setgradientlist(A::NMRData, [dimnumber], relativegradientlist, Gmax=nothing)\n\nReturn a new NMRData with a gradient axis containing the passed values. If no maximum strength is specified, a default gradient strength of 0.55 T m⁻¹ will be set, but a warning raised for the user.\n\nIf a dimension number is specified, that dimension will be replaced. If not, the function will search for a unique non-frequency dimension, and replace that. If there are multiple non-frequency dimensions, the dimension number must be specified explicitly, and the function will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.setkinetictimes-Tuple{}","page":"API","title":"NMRTools.NMRBase.setkinetictimes","text":"setkinetictimes(A::NMRData, [dimnumber], tvals, units=\"\")\n\nReturn a new NMRData with a kinetic time axis containing the passed values (and optionally, units). If a dimension number is specified, that dimension will be replaced with a TkinDim. If not, the function will search for a unique non-frequency dimension, and replace that. If there are multiple non-frequency dimensions, the dimension number must be specified explicitly, and the function will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.setrelaxtimes-Tuple{}","page":"API","title":"NMRTools.NMRBase.setrelaxtimes","text":"setrelaxtimes(A::NMRData, [dimnumber], tvals, units=\"\")\n\nReturn a new NMRData with a relaxation time axis containing the passed values (and optionally, units). If a dimension number is specified, that dimension will be replaced with a TrelaxDim. If not, the function will search for a unique non-frequency dimension, and replace that. If there are multiple non-frequency dimensions, the dimension number must be specified explicitly, and the function will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.shiftdim-Tuple{Any, Any, Any}","page":"API","title":"NMRTools.NMRBase.shiftdim","text":"shiftdim!(data::NMRData, dim_ref, offset)\n\nAdd an offset to a frequency dimension in an NMRData object. The dimension can be specified as a numerical index or an object like F1Dim. The metadata is copied using replacedimension, and an entry is added or updated in the dimension metadata to record the offset change.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.spin-Tuple{Nucleus}","page":"API","title":"NMRTools.NMRBase.spin","text":"spin(n::Nucleus)\n\nReturn the spin quantum number of nucleus n, or nothing if not defined.\n\nExamples\n\njulia> spin(H1)\n1//2\n\nSee also Coherence.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.watts-Tuple{Power}","page":"API","title":"NMRTools.NMRBase.watts","text":"watts(p::Power)\n\nGet the power level in Watts.\n\nExample\n\np = Power(20.0, :dB)\nwatts(p)  # 0.01\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.FQList","page":"API","title":"NMRTools.NMRIO.FQList","text":"FQList(values, unit::Symbol, relative::Bool)\n\nRepresents a frequency list. unit can be :Hz or :ppm, and relative indicates whether the frequency is given relative to SFO (true) or BF (false).\n\nRaw values can be extracted using the data function, or (better) as absolute chemical shifts (in ppm) or relative offsets (in Hz) using ppm and hz functions.\n\nSee also: ppm, hz.\n\n\n\n\n\n","category":"type"},{"location":"api/#NMRTools.NMRBase.hz-Tuple{FQList, FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.hz","text":"hz(f::FQList, ax::FrequencyDimension)\n\nReturn frequency list values as offsets relative to the spectrometer frequency, in Hz.\n\nSee also: ppm\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRBase.ppm-Tuple{FQList, FrequencyDimension}","page":"API","title":"NMRTools.NMRBase.ppm","text":"ppm(f::FQList, ax::FrequencyDimension)\n\nReturn frequency list values in ppm (in absolute terms, i.e. relative to 0 ppm).\n\nSee also: hz\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO._find_dimension_path","page":"API","title":"NMRTools.NMRIO._find_dimension_path","text":"_find_dimension_path(key, annotations, prefix=\"\")\n\nFind the dotted path to a key in the annotations dictionary. Returns the path that should match entries in the dimensions array.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRIO._is_programmatic_pattern-Tuple{Any}","page":"API","title":"NMRTools.NMRIO._is_programmatic_pattern","text":"_is_programmatic_pattern(value) -> Bool\n\nCheck if a value is a programmatic list pattern. Must be a Dict with \"type\" key and either \"step\" or \"end\" key.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO._resolve_parameter-Tuple{String, NMRData}","page":"API","title":"NMRTools.NMRIO._resolve_parameter","text":"_resolve_parameter(param_str::String, spec::NMRData) -> Union{Nothing, Any}\n\nAttempt to resolve a parameter string using the acqus data. Returns the resolved value or nothing if not a recognized parameter.\n\nHandles parameter patterns (case-insensitive):\n\nIndexed parameters: p1, pl1, d20, cnst8, gpz6, etc.\nNucleus assignments: f1, f2, f3, f4\nAny other parameter names that exist in acqus (including lists)\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO._resolve_programmatic_pattern-Tuple{String, Dict, Dict, NMRData, Vector}","page":"API","title":"NMRTools.NMRIO._resolve_programmatic_pattern","text":"_resolve_programmatic_pattern(key, pattern, root_annotations, spec, dimensions)\n\nResolve a single programmatic list pattern to a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO._resolve_programmatic_recursive!-Tuple{Dict, Dict, NMRData, Vector}","page":"API","title":"NMRTools.NMRIO._resolve_programmatic_recursive!","text":"_resolve_programmatic_recursive!(obj, root_annotations, spec, dimensions)\n\nRecursively traverse annotations to find and resolve programmatic list patterns.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.exampledata-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.exampledata","text":"exampledata(name::String)\n\nLoad example NMR data provided with NMRTools.jl\n\nArguments\n\nname::String : Name of example data set to load. Call exampledata() to list available data.\n\nReturns\n\nNMR data object(s) corresponding to the requested example data set.\n\nExample\n\ndata = exampledata(\"1D_19F_titration\")\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.getformat-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.getformat","text":"getformat(filename)\n\nTake an input filename and return either :ucsf, :nmrpipe, :pdata (bruker processed), or :unknown after checking whether the filename matches any known format.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.loadnmr-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.loadnmr","text":"loadnmr(filename, experimentfolder=nothing)\n\nMain function for loading NMR data. experimentfolder contains the path to an experiment directory, for identification of metadata, if the filename is not directly within an experiment.\n\nReturns an NMRData structure, or throws an NMRToolsError is there is a problem.\n\nExamples\n\nnmrPipe import:\n\nloadnmr(\"exampledata/1D_1H/1/test.ft1\");\nloadnmr(\"exampledata/1D_19F/1/test.ft1\");\nloadnmr(\"exampledata/2D_HN/1/test.ft2\");\nloadnmr(\"exampledata/pseudo2D_XSTE/1/test.ft1\");\nloadnmr(\"exampledata/pseudo3D_HN_R2/1/ft/test%03d.ft2\");\n\nBruker pdata import:\n\nloadnmr(\"exampledata/1D_19F/1\");\nloadnmr(\"exampledata/1D_19F/1/\");\nloadnmr(\"exampledata/1D_19F/1/pdata/1\");\nloadnmr(\"exampledata/1D_19F/1/pdata/1/\");\n\nucsf (Sparky) import:\n\nloadnmr(\"exampledata/2D_HN/1/hmqc.ucsf\");\nloadnmr(\"exampledata/1D_19F/1/\");\nloadnmr(\"exampledata/1D_19F/1/pdata/1\");\nloadnmr(\"exampledata/1D_19F/1/pdata/1/\");\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.loadnmrpipe1d-Tuple{Any, Any, Any}","page":"API","title":"NMRTools.NMRIO.loadnmrpipe1d","text":"loadnmrpipe1d(filename, md, mdax)\n\nReturn an NMRData array containing spectrum and associated metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.loadnmrpipe2d-Tuple{String, Any, Any}","page":"API","title":"NMRTools.NMRIO.loadnmrpipe2d","text":"loadnmrpipe2d(filename, md, mdax)\n\nReturn NMRData containing spectrum and associated metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.loadnmrpipe3d-Tuple{String, Any, Any}","page":"API","title":"NMRTools.NMRIO.loadnmrpipe3d","text":"loadnmrpipe3d(filename, md, mdax)\n\nReturn NMRData containing spectrum and associated metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.loadpdata","page":"API","title":"NMRTools.NMRIO.loadpdata","text":"loadpdata(filename, allcomponents=false)\n\nFilename will be a reference to a pdata folder.\n\n\n\n\n\n","category":"function"},{"location":"api/#NMRTools.NMRIO.parse_annotations-Tuple{String}","page":"API","title":"NMRTools.NMRIO.parse_annotations","text":"parse_annotations(content::String) -> Dict{String, Any}\n\nParse pulse programme annotations from content string. Annotations are embedded  within pulse programme comments marked with ;@ at the start of lines.\n\nThe function:\n\nFilters out lines starting with ;@\nStrips the ;@ prefix from each line\nParses the resulting YAML document into a dictionary\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsefqlist-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parsefqlist","text":"parsefqlist(lines)\n\nReturn contents of the specified fqlist.\n\nfqlists can have several different formats:\n\nfirst line   | reference   | unit\n\n         | sfo         | Hz\n\nsfo hz       | sfo         | Hz sfo ppm      | sfo         | ppm bf hz        | bf          | Hz bf ppm       | bf          | ppm p            | sfo         | ppm P            | bf          | ppm\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsenmrpipeheader-Tuple{Vector{Float32}}","page":"API","title":"NMRTools.NMRIO.parsenmrpipeheader","text":"parsenmrpipeheader(header)\n\nPass a 512 x 4 byte array containing an nmrPipe header file, and returns dictionaries of metadata. The nmrPipe header format is defined in fdatap.h.\n\nReturn values\n\nmd: dictionary of spectrum metadata\nmdax: array of dictionaries containing axis metadata\n\nExamples\n\nmd, mdax = parsenmrpipeheader(header)\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsepulseprogramlists!-Tuple{Any, Any}","page":"API","title":"NMRTools.NMRIO.parsepulseprogramlists!","text":"Example lines to parse: define list<gradient> EA=<EA> define list<gradient> EA3 = { 1.0000 0.8750 } define list<pulse> taulist = <$VPLIST> define list<power> powerlist = <$VALIST> define list<gradient> diff=<Difframp> define list<frequency> F19sat = <$FQ1LIST>\n\nNB gradient files have weird syntax!!\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parseucsfaxisheader-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parseucsfaxisheader","text":"parse ucsf axis header into a dictionary\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parseucsfheader-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parseucsfheader","text":"parse ucsf file header into a dictionary\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsevalist-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parsevalist","text":"return valist contents as Powers\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsevdlist-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parsevdlist","text":"return vdlist contents in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.parsevplist-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.parsevplist","text":"return vplist contents in seconds\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.replacedurations!-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.replacedurations!","text":"replacedurations!(dic)\n\nEnsure all durations in the acqus dictionary are in seconds.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.replacepowers!-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.replacepowers!","text":"replacepowers!(dic)\n\nEnsure all powers in the acqus dictionary are stored as Power types.\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.resolve_parameter_references!-Tuple{Dict, NMRData}","page":"API","title":"NMRTools.NMRIO.resolve_parameter_references!","text":"resolve_parameter_references!(annotations::Dict{String, Any}, spec::NMRData)\n\nRecursively traverse the annotations dictionary and resolve parameter references. References are bare parameter names like p1, pl1, d20, VALIST, etc.\n\nParameters are resolved using the acqus() function to get values from the acqus file.\n\nArguments\n\nannotations::Dict{String, Any}: Annotations dictionary to modify in-place\nspec::NMRData: NMRData object containing acqus metadata\n\nExamples\n\n# Before resolution: {\"pulse\": \"p1\", \"power\": \"pl1\", \"duration\": \"VDLIST\"}\n# After resolution: {\"pulse\": 9.2, \"power\": Power(...), \"duration\": [0.01, 0.02, ...]}\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.resolve_programmatic_lists!-Tuple{Dict, NMRData}","page":"API","title":"NMRTools.NMRIO.resolve_programmatic_lists!","text":"resolve_programmatic_lists!(annotations::Dict{String, Any}, spec::NMRData)\n\nResolve programmatic list patterns in annotations to actual vectors.\n\nProgrammatic lists are specified as dictionaries with:\n\ntype: \"linear\" or \"log\" (logarithmic)\nstart: starting value\nstep: step size (for linear with start/step)\nend: ending value (for linear or log with start/end)\n\nThe function:\n\nIdentifies fields containing programmatic list patterns ({type, start, step/end})\nFinds the dimension number for that field from the dimensions annotation\nGets the number of points in that dimension\nReplaces the pattern with a correctly sized vector\n\nExamples\n\n# Linear spacing with start/step\n# {type: linear, start: p9, step: p9} with 10 points → [p9, 2*p9, 3*p9, ...]\n\n# Linear spacing with start/end\n# {type: linear, start: 0.001, end: 0.1} with 10 points → [0.001, 0.012, ..., 0.1]\n\n# Logarithmic spacing with start/end\n# {type: log, start: 0.001, end: 0.1} with 10 points → [0.001, 0.0016, ..., 0.1]\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.sumexpts-Tuple","page":"API","title":"NMRTools.NMRIO.sumexpts","text":"sumexpts(inputexpts...; out, weights=[])\n\nSum a collection of Bruker NMR experiments, with optional weighting factors. Data will be truncated to fit the shortest data file.\n\nArguments\n\ninputexpts...: Input experiment names (strings or integers)\nout: Output experiment name (string or integer)\nweights: Optional vector of weights for each input experiment\n\nDetails\n\nExperiment names should be either strings with filenames or integers converted to strings\nIf weights are supplied, the length must match the number of input experiments\nFirst input experiment is used as a template for the output experiment\nFor 1D experiments, 'fid' files are added; for nD experiments, 'ser' files are added\nProcessed data files in pdata/1 are removed, other pdata subdirectories are deleted\nUpdates the title file with information about the summed experiments\nUpdates the number of scans in the acqus file to be the sum of individual experiments\nPrompts before overwriting any existing experiment\n\n\n\n\n\n","category":"method"},{"location":"api/#NMRTools.NMRIO.topspinversion-Tuple{Any}","page":"API","title":"NMRTools.NMRIO.topspinversion","text":"parsetopspinversion(acqusfilename)\n\nReturn the TopSpin version as a VersionNumber (e.g. v\"4.2.0\").\n\nThis is obtained from the end of the first line of the acqus file, e.g.\n\n##TITLE= Parameter file, TopSpin 4.2.0\n##TITLE= Parameter file, TOPSPIN\t\tVersion 2.1\n##TITLE= Parameter file, TOPSPIN\t\tVersion 3.2\n\n\n\n\n\n","category":"method"},{"location":"tutorial-metadata/#Metadata","page":"Metadata","title":"Metadata","text":"NMRData objects contain comprehensive metadata on processing and acquisition parameters. These are populated automatically when loading a spectrum. Entries are divided into spectrum metadata – associated with the experiment in general – and axis metadata, that are associated with a particular dimension of the data.\n\nExamples of spectrum metadata include: number of scans, receiver gain, pulse program, experiment title, number of dimensions, noise level (calculated when the spectrum is loaded), acquisition parameters (pulse lengths etc, from the acqus file), contents of auxilliary files (e.g. vclists and vdlists).\n\nExamples of axis metadata include: the number of points, the original time domain size (before zero filling, linear prediction or extraction of a subregion), carrier frequency, spectrum width, window function used for processing.","category":"section"},{"location":"tutorial-metadata/#Accessing-spectrum-metadata","page":"Metadata","title":"Accessing spectrum metadata","text":"Metadata are stored in a dictionary labelled by symbols such as :ns or :pulseprogram. This dictionary can be accessed using the metadata function.\n\nusing NMRTools\n# load an example 2D 1H,15N HMQC spectrum\nspec = exampledata(\"2D_HN\")\n\nmetadata(spec)\n\nFor convenience, entries can be accessed by passing a second argument to the metadata function:\n\nmetadata(spec, :title)\n\nor directly from the spectrum using a dictionary-style lookup:\n\nspec[:ns]","category":"section"},{"location":"tutorial-metadata/#Accessing-axis-metadata","page":"Metadata","title":"Accessing axis metadata","text":"Axis metadata can be accessed by providing an additional argument to the metadata function, specifying the axis numerically:\n\nmetadata(spec, 1)\n\nAxes can also be accessed by their type, e.g. F1Dim or F2Dim:\n\nmetadata(spec, F2Dim)\n\nAgain, for convenience entries can be accessed by passing an additional argument to the metadata function:\n\nmetadata(spec, F1Dim, :label)\n\nor directly from the spectrum object using a dictionary-style lookup alongside an axis reference:\n\nspec[2, :offsetppm]","category":"section"},{"location":"tutorial-metadata/#Accessing-acquisition-parameters","page":"Metadata","title":"Accessing acquisition parameters","text":"Spectrometer acquisition parameters are automatically parsed from the acqus file when data are loaded. This is stored as a dictionary in the :acqus entry of the spectrum metadata, but can more conveniently be accessed through the function acqus(spec, parametername). Parameter names can be provided either as strings (case insensitive, e.g. \"TE\" for the temperature) or as lowercase symbols (e.g. :te).\n\nacqus(spec, :te)\n\nArrayed parameters such as pulse lengths are returned as dictionaries:\n\nacqus(spec, :p)\n\nFor convenience, particular entries can be accessed directly by supplying an additional index parameter:\n\nacqus(spec, :cnst, 4)\n\nnote: Note\nArrayed parameters such as pulse lengths, delays, etc. are returned as dictionaries rather than lists to avoid indexing confusion between Bruker arrays, which are zero-based, and Julia arrays, which are unit-based.","category":"section"},{"location":"tutorial-metadata/#Auxiliary-files","page":"Metadata","title":"Auxiliary files","text":"If present, files such as vclist and vdlist are imported and can be accessed through the acqus function:\n\nrelaxation_experiment = exampledata(\"pseudo3D_HN_R2\")\nacqus(relaxation_experiment, :vclist)","category":"section"},{"location":"tutorial-metadata/#Window-functions","page":"Metadata","title":"Window functions","text":"The window functions used for data processing are identified when experiments are loaded. These are represented by subtypes of WindowFunction, which contain appropriate parameters specifying the particular function applied together with the acquisition time t_mathrmmax (calculated at the point of application, i.e. after linear prediction but before zero filling).\n\nWindow functions are stored as axis metadata and can be accessed through the :window parameter:\n\nspec[2, :window] # get the window function for the second dimension\n\nAvailable window functions are:\n\nNullWindow(tmax): no window function applied\nUnknownWindow(tmax): unrecognised window function\nExponentialWindow(lb, tmax): line broadening specified in Hz\nSineWindow(offset, endpoint, power, tmax): a supertype encompassing some special cases\nCosWindow(tmax): apodization by a pure half-cosine window\nCos²Window(tmax): apodization by a pure half-cosine-squared window\nGeneralSineWindow(offset, endpoint, power, tmax): other general cases\nGaussWindow(expHz, gaussHz, center, tmax): a supertype encompassing some special cases\nLorentzToGaussWindow(expHz, gaussHz, tmax)\nGeneralGaussWindow(expHz, gaussHz, center, tmax): other general cases","category":"section"},{"location":"ref-windows/#Window-functions","page":"Window functions","title":"Window functions","text":"","category":"section"},{"location":"ref-dimensions/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"metadata/#Metadata-Overview","page":"Overview","title":"Metadata Overview","text":"NMRData objects contain comprehensive metadata on processing and acquisition parameters that are populated automatically upon loading a spectrum. This metadata system provides access to all the information needed to understand, process, and analyze NMR data.","category":"section"},{"location":"metadata/#Types-of-metadata","page":"Overview","title":"Types of metadata","text":"Metadata is organized into two categories:\n\nSpectrum metadata: Information about the experiment as a whole (number of scans, receiver gain, pulse program, temperature, etc.)\nAxis metadata: Information specific to each dimension (carrier frequency, spectral width, window functions, etc.)","category":"section"},{"location":"metadata/#Quick-start","page":"Overview","title":"Quick start","text":"","category":"section"},{"location":"metadata/#Accessing-spectrum-metadata","page":"Overview","title":"Accessing spectrum metadata","text":"using NMRTools\n\n# Load example spectrum\nspec = exampledata(\"2D_HN\")\n\n# Access using the metadata function\nmetadata(spec, :ns)\n\n# Or use dictionary-style lookup\nspec[:pulseprogram]","category":"section"},{"location":"metadata/#Accessing-axis-metadata","page":"Overview","title":"Accessing axis metadata","text":"# By dimension type\nspec[F2Dim, :label]\n\n# Or by dimension number\nspec[2, :swhz]","category":"section"},{"location":"metadata/#Accessing-acquisition-parameters","page":"Overview","title":"Accessing acquisition parameters","text":"# Get acquisition parameter\nacqus(spec, :te)\n\n# Access arrayed parameters\nacqus(spec, :p, 1)  # First pulse length","category":"section"},{"location":"metadata/#Special-metadata-types","page":"Overview","title":"Special metadata types","text":"NMRTools provides specialized types for handling complex metadata:","category":"section"},{"location":"metadata/#Window-functions","page":"Overview","title":"Window functions","text":"Window functions (apodization) applied during processing are stored as structured objects that preserve all parameters:\n\n# Get window function for a dimension\nwin = spec[F2Dim, :window]\n\nSee the Window functions page for detailed documentation.","category":"section"},{"location":"metadata/#Power-levels","page":"Overview","title":"Power levels","text":"Power levels are represented as Power objects that handle conversion between Watts and dB:\n\n# Power levels from acqus file\np = acqus(spec, :pl, 1)\ndb(p)      # Get as dB\nwatts(p)   # Get as Watts\n\nSee the Power levels page for detailed documentation.","category":"section"},{"location":"metadata/#Frequency-lists","page":"Overview","title":"Frequency lists","text":"Frequency lists (from fq1list, etc.) are stored as FQList objects that preserve unit and reference information:\n\n# Get frequency list\nfqlist = acqus(spec, :fq1list)\n\n# Extract as ppm or Hz\nppm(fqlist, dims(spec, F2Dim))\nhz(fqlist, dims(spec, F2Dim))\n\nSee the Frequency lists page for detailed documentation.","category":"section"},{"location":"metadata/#Standard-metadata-keys","page":"Overview","title":"Standard metadata keys","text":"","category":"section"},{"location":"metadata/#Spectrum-metadata-symbols","page":"Overview","title":"Spectrum metadata symbols","text":"Symbol Description\n:filename Original filename or template\n:format :NMRPipe or :bruker\n:title Contents of pdata/1/title\n:label First line of title, used for captions\n:pulseprogram Pulse program (PULPROG) from acqus file\n:ndim Number of dimensions\n:acqusfilename Path to associated acqus file\n:acqus Dictionary of acqus data\n:ns Number of scans\n:rg Receiver gain\n:noise RMS noise level\n:solvent Solvent string, e.g. \"H2O+D2O\"\n:temperature Temperature in K\n:nuclei Set of Nucleus values","category":"section"},{"location":"metadata/#Axis-metadata-symbols","page":"Overview","title":"Axis metadata symbols","text":"Symbol Description\n:pseudodim Flag indicating non-frequency domain data\n:npoints Final number of (real) data points in dimension (after extraction)\n:td Number of complex points acquired\n:tdzf Number of complex points when FT executed, including LP and ZF\n:bf Base frequency, in Hz\n:sf Carrier frequency, in Hz\n:offsethz Carrier offset from bf, in Hz\n:offsetppm Carrier offset from bf, in ppm\n:swhz Spectrum width, in Hz\n:swppm Spectrum width, in ppm\n:region Extracted region, expressed as a range in points, otherwise missing\n:window WindowFunction object indicating applied apodization\n:nucleus Nucleus enum value for this dimension","category":"section"},{"location":"metadata/#Auxiliary-files","page":"Overview","title":"Auxiliary files","text":"Files such as vclist, vdlist, and frequency lists are automatically imported when present:\n\n# Access variable delay list\nrelaxation_spec = exampledata(\"pseudo3D_HN_R2\")\nacqus(relaxation_spec, :vclist)\n\nNMRTools performs automatic unit conversion:\n\n:vclist: Variable loop counter (dimensionless)\n:vdlist: Variable delays, in seconds\n:valist: Variable amplitude, in dB (converted from Watts if necessary)\n:vplist: Variable pulse lengths, in seconds\n:fq1list through :fq8list: Frequency lists (see Frequency lists)","category":"section"},{"location":"metadata/#Next-steps","page":"Overview","title":"Next steps","text":"Times and frequencies: Learn about units used for pulse lengths, delays and frequencies\nPower levels: Representation of powers and RF field strength calculations\nFrequency lists: Understand frequency list handling and conversions\nWindow functions: Explore apodization functions and lineshape effects\nTutorial: Metadata: Step-by-step introduction to working with metadata (see Tutorials section)\nReference: Metadata: Complete API reference for metadata functions (see Reference guide section)","category":"section"},{"location":"tutorial-data/#Working-with-NMR-data","page":"Working with NMR data","title":"Working with NMR data","text":"NMR measurements are arrays of data, with additional numerical data associated with each dimension, or axis. Within NMRTools, these data are stored as NMRData structures, which provides a convenient way to encapsulate both the data, axis information, and additional metadata providing information on acquisition or processing.","category":"section"},{"location":"tutorial-data/#Loading-NMR-data","page":"Working with NMR data","title":"Loading NMR data","text":"NMR data are loaded using the loadnmr function. This can handle processed Bruker experiments, or NMRPipe-format data.\n\n# load bruker experiment number 1 from a directory '2D_HN'\n# by default, NMRTools will load bruker processed data from proc 1\nspec2d = loadnmr(\"exampledata/2D_HN/1\")\n\n# load a different processed spectrum\nspec1d = loadnmr(\"exampledata/2D_HN/1/pdata/101\")\n\n# load data from NMRPipe format, using a template\nspec3d = loadnmr(\"exampledata/pseudo3D_HN_R2/1/ft/test%03d.ft2\")\n\ntip: Tip\nloadnmr will attempt to locate and parse acquisition metadata, such as acqus files. If the spectrum file is located elsewhere (for example, if you are loading a file that was processed with NMRPipe), then you can specify the path to the experiment folder using the experimentfolder keyword argument.\n\nWhen spectra are loaded, a simple algorithm runs to estimate the noise level, which is often used for subsequent plotting commands.","category":"section"},{"location":"tutorial-data/#Manipulating-spectrum-data","page":"Working with NMR data","title":"Manipulating spectrum data","text":"NMRData structures encapsulate a standard Julia array. This can be accessed using the data command. However, through the magic of multiple dispatch, most operations will work transparently on NMRData variables as if they are regular arrays, with the added benefit that axis information and metadata are preserved. Data can be sliced and accessed like a regular array using the usual square brackets:\n\nspec1d[100:105]\nspec2d[3:4, 10:14]\n\nHowever, more conveniently, value-based selectors can also be used to locate data using chemical shifts. Three selectors are defined:\n\nAt(x): select data precisely at the specified value\nNear(x): select data at the nearest matching position\nx .. y: select the range of data between x and y (closed interval)\n\nFor example:\n\nspec1d[8.2 .. 8.3] # select between 8.2 and 8.3 ppm\nspec2d[Near(8.25), 123 .. 124] # select near 8.25 ppm in the first dimension\n                               # and between 123 and 124 ppm in the second dimension\n\nWhen data are sliced, new NMRData structures are created and their axes are updated to match the new data size.\n\nwarning: Warning\nWhen NMRData structures are sliced, copied, or otherwise modified, they inherit the same dictionary of metadata as the original variable. This means that any changes to metadata will affect both variables. To resolve this, make a deepcopy of the variable. Note also that any acquisition metadata might not reflect the correct shape of the data any more.","category":"section"},{"location":"tutorial-data/#Accessing-axis-data","page":"Working with NMR data","title":"Accessing axis data","text":"Information on data dimensions is stored in NMRDimension structures. These can be accessed with the dims function:\n\n# get the first dimension of this two-dimensional experiment\nusing NMRTools # hide\nspec2d = exampledata(\"2D_HN\"); # hide\ndims(spec2d, 1)\n\nNMRDimensions can be treated like vectors (one-dimensional arrays) for most purposes, including indexing and slicing. Value-based selectors can also be used, as for spectrum data. Like spectrum data, the underlying numerical data can be accessed if needed using the data function.\n\nA heirarchy of types are defined for NMR dimensions, reflecting the variety of different experiments:\n\nNMRDimension\nFrequencyDimension: with specific types F1Dim to F4Dim\nNonFrequencyDimension\nTimeDimension:\nTrelaxDim: for relaxation times\nTkinDim: for kinetic evolution times\nT1Dim to T4Dim: for general frequency evolution periods\nGradientDimension: for e.g. diffusion measurements, with specific types G1Dim to G4Dim\nUnknownDimension: with specific types X1Dim to X4Dim","category":"section"},{"location":"tutorial-data/#Chemical-shift-referencing","page":"Working with NMR data","title":"Chemical shift referencing","text":"The shiftdim function allows you to adjust the referencing of your NMR spectrum by adding a specified offset to the chemical shift values along a given dimension. This can be useful if you need to correct referencing errors or align spectra.\n\nTo use shiftdim, you need to specify the NMRData object, the dimension to adjust, and the offset value to add. Here is a simple example:\n\nusing NMRTools, Plots #hide\n\n# Load example data\nspec2d_original = exampledata(\"2D_HN\")\n\n# Add an offset of 0.1 ppm to the first dimension (specified as a number)\nspec2d = shiftdim(spec2d_original, 1, 0.1)\n\n# Add a further offset of -0.5 ppm to the second dimension (specified as F2Dim)\nspec2d = shiftdim(spec2d, F2Dim, -0.5)\n\nlabel!(spec2d_original, \"unreferenced\")\nlabel!(spec2d, \"referenced\")\nplot([spec2d_original, spec2d])\nsavefig(\"plot-offset.svg\"); nothing # hide\n\n(Image: )\n\nIn this example, the chemical shift values in the first dimension of spec2d are increased by 0.1 ppm, and the values in the second dimension are decreased by 0.5 ppm.\n\nnote: Note\nThe shiftdim function will adjust metadata (:offsetppm, :offsethz and :sf) to keep track of the altered referencing. A new metadata entry :referenceoffset will be created to keep track of this referencing.","category":"section"},{"location":"tutorial-data/#Accessing-metadata","page":"Working with NMR data","title":"Accessing metadata","text":"NMRData objects contain comprehensive metadata on processing and acquisition parameters that are populated automatically upon loading a spectrum. Entries are divided into spectrum metadata - associated with the experiment in general - and axis metadata, that are associated with a particular dimension of the data.\n\nMetadata entries are labelled by symbols such as :ns or :pulseprogram. Entries can be accessed using the metadata function, or directly as a dictionary-style lookup:\n\nspec2d = exampledata(\"2D_HN\"); # hide\nmetadata(spec2d, :ns)\nspec2d[:title]\n\nAcquisition parameters from Bruker acqus files are also parsed when loading data, and can be accessed using the acqus function. Parameters are specified either as lower-case symbols or strings (not case-sensitive). An index can be specified for arrayed parameters such as pulse lengths or delays.\n\nacqus(spec2d, \"TE\")\nacqus(spec2d, :p, 1)\n\nAxis metadata can be accessed by providing an additional label, which can either be numerical or the appropriate NMRDimension type, such as F1Dim etc:\n\nmetadata(spec2d, F2Dim, :label)\nspec2d[2, :bf]\nspec2d[F2Dim, :window]","category":"section"},{"location":"ref-plots/#Plotting-with-JuliaPlots","page":"Plotting with JuliaPlots","title":"Plotting with JuliaPlots","text":"","category":"section"},{"location":"ref-data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"quickstart/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"quickstart/#Installing-NMRTools","page":"Getting started","title":"Installing NMRTools","text":"Install NMRTools.jl through the Julia package manager:\n\nusing Pkg\nPkg.add(\"NMRTools\")\n\nThe examples in this tutorial also using the Plots package, which can be obtained similarly.","category":"section"},{"location":"quickstart/#Plot-a-1D-spectrum","page":"Getting started","title":"Plot a 1D spectrum","text":"Let's load some example data. This can be a Bruker experiment directory, a specific pdata folder, or an NMRPipe-format file.\n\nusing NMRTools, Plots\nspec = exampledata(\"1D_19F\")\n\nNMRTools contains Plots recipes for common types of spectrum. To plot our 1D spectrum, we just use the plot command:\n\nplot(spec)\nsavefig(\"plot-y.svg\"); nothing # hide\n\n(Image: )\n\nWe could zoom in on a particular region using the usual xlims arguments from Plots, but we can also select a chemical shift range from the data directly. To do this, we use square brackets [...] to access the data like an array, but use the .. selector to specify our chemical shift range:\n\nplot(spec[-124.5 .. -123])\nsavefig(\"plot-y2.svg\"); nothing # hide\n\n(Image: )\n\nAll plots can be saved as high quality vector graphics or png files, using the savefig command:\n\nsavefig(\"myspectrum.pdf\")","category":"section"},{"location":"quickstart/#Plot-a-2D-spectrum","page":"Getting started","title":"Plot a 2D spectrum","text":"Two-dimensional spectra can be plotted in exactly the same way as for 1Ds.\n\nusing NMRTools, Plots # hide\nspec = exampledata(\"2D_HN\")\nplot(spec)\nsavefig(\"plot-2d.svg\"); nothing # hide\n\n(Image: )\n\nContour levels are set to five times the noise level. The most convenient way to adjust this is simply to multiply or divide the spectrum by some scaling factor. You can also adjust the title - by default taken from the spectrum label - using the title keyword. Use an empty string (title=\"\") to remove the title.\n\nplot(spec / 2, title=\"spectrum divided by two\")\nsavefig(\"plot-2d-scaled.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"quickstart/#Accessing-your-data","page":"Getting started","title":"Accessing your data","text":"Spectrum data and associated axis information, metadata, etc, is encapsulated in an NMRData structure.\n\nusing NMRTools # hide\nspec = exampledata(\"1D_19F\")\n\nData can be accessed with conventional array indexing, but also using the value-based selectors, Near and ..:\n\nspec[100:105]\nspec[Near(-124)]\nspec[-124 .. -123.5]\n\nThis also works for multidimensional data. For example:\n\nspec2d = exampledata(\"2D_HN\")\nspec2d[8.1 .. 8.3, Near(124)]\n\nA plain array of data for the spectrum can be obtained from this using the data command:\n\ndata(spec)\n\nSimilarly, a plain vector containing axis values can be obtained from this using the data command, passing an additional argument to specify the dimension. This can either be a number or the axis type, e.g. F1Dim:\n\ndata(spec, 1)","category":"section"},{"location":"tutorial-diffusion/#1D-diffusion-analysis","page":"Diffusion analysis","title":"1D diffusion analysis","text":"Let's analyse a 15N-edited XSTE measurement of translational diffusion. This experiment was acquired as a single pseudo-2D measurement, with gradient strengths ranging from 2 to 98% of the maximum strength, 0.55 T/m.\n\nFirst, we need to load the required packages. We will use LsqFit for the non-linear least squares fitting, Measurements to handle uncertainties, and Statistics for calculation of means and standard deviations.\n\nusing NMRTools\nusing Plots\nusing LsqFit\nusing Measurements\nusing Statistics\n\nspec = exampledata(\"pseudo2D_XSTE\")","category":"section"},{"location":"tutorial-diffusion/#Set-up-parameters","page":"Diffusion analysis","title":"Set up parameters","text":"The file we have just loaded has an UnknownDimension as the non-frequency dimension. We need to replace this with a GradientDimension and set the gradient strengths that were used. We do this with the setgradientlist function:\n\ngradients = LinRange(0.02, 0.98, size(spec, X2Dim))\nGmax = 0.55 # T/m\n\nspec = setgradientlist(spec, gradients, Gmax)\n\nNext, we extract or set other acquisition parameters required for analysis. In particular, we extract the diffusion pulse length, δ, and the diffusion delay, Δ, from the acqus file. We also specify the chemical shift ranges used for plotting, fitting, and for determination of the noise level.\n\nδ = acqus(spec, :p, 30) * 2    # gradient pulse length = p30/2\nΔ = acqus(spec, :d, 20)        # diffusion delay = d20\nσ = 0.9                        # gradient pulse shape factor (for SMSQ10)\n\ncoherence = SQ(H1)             # coherence for diffusion encoding\nγ = gyromagneticratio(coherence)            # calculate effective gyromagnetic ratio\n\ng = data(spec, G2Dim)          # list of gradient strengths\n\n# select chemical shift ranges for plotting and fitting\nplotrange = 6 .. 10 # ppm\ndatarange = 7.7 .. 8.6 # ppm\nnoiseposition = 10.5 # ppm\nnothing # hide","category":"section"},{"location":"tutorial-diffusion/#Plot-the-data","page":"Diffusion analysis","title":"Plot the data","text":"To take a quick look at the data, we can plot the experiment either as 3D lines using the plot command, or as a heatmap:\n\nplot(\n    plot(spec[plotrange,:]),\n    heatmap(spec[plotrange,:])\n)\nsavefig(\"tutorial-diffusion-plot.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-diffusion/#Calculate-noise-and-peak-integrals","page":"Diffusion analysis","title":"Calculate noise and peak integrals","text":"Now, we can determine the measurement noise, by taking the standard deviation of integrals across the different gradient points:\n\n# create a selector for the noise, matching the width of the data range\nnoisewidth = datarange.right - datarange.left\nnoiserange = (noiseposition-0.5noisewidth)..(noiseposition+0.5noisewidth)\n\n# integrate over the noise regions and take the standard deviation\n# (calculate the sum over the frequency dimension F1Dim, and use\n# `data` to convert from NMRData to a regular array)\nnoise = sum(spec[noiserange,:], dims=F1Dim) |> data |> std\n\n# calculate the integral of the data region similarly, using vec to convert to a list\nintegrals = sum(spec[datarange,:], dims=F1Dim) |> data |> vec\n\n# normalise noise and integrals by the maximum value\nnoise /= maximum(integrals)\nintegrals /= maximum(integrals)\nnothing # hide","category":"section"},{"location":"tutorial-diffusion/#Fitting","page":"Diffusion analysis","title":"Fitting","text":"Now, we can fit the data to the Stejskal-Tanner equation using the LsqFit package.\n\n# model parameters are (I0, D) - scale D by 1e-10 for a nicer numerical value\nmodel(g, p) = p[1] * exp.(-(γ*δ*σ*g).^2 .* (Δ - δ/3) .* p[2] .* 1e-10)\n\np0 = [1.0, 1.0] # rough guess of initial parameters\n\nfit = curve_fit(model, g, integrals, p0) # run the fit\n\n# extract the fit parameters and standard errors\npfit = coef(fit)\nerr = stderror(fit)\nD = (pfit[2] ± err[2]) * 1e-10","category":"section"},{"location":"tutorial-diffusion/#Plot-the-results","page":"Diffusion analysis","title":"Plot the results","text":"Finally, plot the results:\n\nx = LinRange(0, maximum(g)*1.1, 100)\nyfit = model(x, pfit)\n\np1 = scatter(g, integrals .± noise, label=\"observed\",\n        frame=:box,\n        xlabel=\"G (T m⁻¹)\",\n        ylabel=\"Integrated signal\",\n        title=\"\",\n        ylims=(0,Inf), # make sure y axis starts at zero\n        widen=true,\n        grid=nothing)\nplot!(p1, x, yfit, label=\"fit\")\n\np2 = plot(spec[plotrange,1],linecolor=:black)\nplot!(p2, spec[datarange,1], fill=(0,:orange), linecolor=:red)\nhline!(p2, [0], c=:grey)\ntitle!(p2, \"\")\n\nplot(p1, p2, layout=(1,2))\nsavefig(\"tutorial-diffusion-fit.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-diffusion/#Estimating-the-hydrodynamic-radius","page":"Diffusion analysis","title":"Estimating the hydrodynamic radius","text":"We can use the known viscosity of water as a function of temperature to estimate the hydrodynamic radius from the measured diffusion coefficient. First, we extract the temperature from the spectrum metadata:\n\nT = acqus(spec, :te)\n\nNext, we can create a little function to calculate viscosity for H2O or D2O solvents as a function of temperature:\n\nfunction viscosity(solvent, T)\n\tif solvent==:h2o\n        A = 802.25336\n        a = 3.4741e-3\n        b = -1.7413e-5\n        c = 2.7719e-8\n        gamma = 1.53026\n        T0 = 225.334\n    elseif solvent==:d2o\n        A = 885.60402\n        a = 2.799e-3\n        b = -1.6342e-5\n        c = 2.9067e-8\n        gamma = 1.55255\n        T0 = 231.832\n    else\n        @error \"solvent not recognised (should be :h2o or :d2o)\"\n    end\n\n    DT = T - T0\n    k = 1.38e-23\n\t\n    return A * (DT + a*DT^2 + b*DT^3 + c*DT^4)^(-gamma)\nend\nη = viscosity(:h2o, T)\n\nFinally, we can use the Stokes-Einstein equation to calculate the hydrodynamic radius:\n\nk = 1.38e-23\nrH = k*T / (6π * η * 0.001 * D) * 1e9 # in nm","category":"section"},{"location":"tutorial-plotrecipes/#Plotting","page":"Plotting","title":"Plotting","text":"NMRTools contains recipes for plotting common types of spectra, using the Plots package.","category":"section"},{"location":"tutorial-plotrecipes/#Plotting-a-1D-spectrum","page":"Plotting","title":"Plotting a 1D spectrum","text":"Let's load and plot an example 1D 19F spectrum, using the loadnmr and plot commands:\n\nusing NMRTools, Plots\nspec = exampledata(\"1D_19F\")\nplot(spec)\nsavefig(\"plot-1D.svg\"); nothing # hide\n\n(Image: )\n\nBy default, plots are titled using the label generated when the data are loaded, which in turn comes from the first line of the title file. Titles can be removed by specifying title=\"\" in the plot command (and the title can be changed in the same manner).\n\nThe plot colour can also be modified, by specifying e.g. c=:black in the plot command.\n\nplot(spec, title=\"\", c=:black)\nsavefig(\"plot-1D-black.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-plotrecipes/#Zooming-in-/-setting-plot-limits","page":"Plotting","title":"Zooming in / setting plot limits","text":"The plot range can be set using the usual xlims argument or command, e.g. passing xlims=[-124,-122] as an option to the plot command.\n\nAlternatively, the region of the spectrum can be selected before plotting, by using the NMRTools .. selector.\n\nplot(spec[-124 .. -123])\nsavefig(\"plot-1D-zoom.svg\"); nothing # hide\n\n(Image: )\n\nThere are two advantages of this approach. If xlims are set, the y axis will be scaled to fit the entire spectrum, including regions that are not actually displayed - this may not show your data at its best. If the data are selected before plotting, the y axis will be scaled according only to the selected region. Secondly, for large spectra, it may be quicker to plot only a subset of the data, and this can result in smaller figure sizes also.","category":"section"},{"location":"tutorial-plotrecipes/#Overlaying-multiple-1D-spectra","page":"Plotting","title":"Overlaying multiple 1D spectra","text":"Multiple experiments can conveniently be loaded from a list of filenames using the map function.\n\n# create a list of bruker experiment directories\nfilenames = [\"../../exampledata/1D_19F_titration/1\",\n             \"../../exampledata/1D_19F_titration/2\",\n             \"../../exampledata/1D_19F_titration/3\",\n             \"../../exampledata/1D_19F_titration/4\",\n             \"../../exampledata/1D_19F_titration/5\",\n             \"../../exampledata/1D_19F_titration/6\",\n             \"../../exampledata/1D_19F_titration/7\",\n             \"../../exampledata/1D_19F_titration/8\",\n             \"../../exampledata/1D_19F_titration/9\",\n             \"../../exampledata/1D_19F_titration/10\",\n             \"../../exampledata/1D_19F_titration/11\"]\nspectra = map(loadnmr, filenames)\nnothing # hide\n\nThis creates a list (Vector) of NMRData containing the individual spectra. To plot this series of spectra, we can simply pass the list of spectra to the plot function:\n\nspectra = exampledata(\"1D_19F_titration\"); # hide\nplot(spectra, xlims=(-125, -122))\nsavefig(\"plot-19F-titration.svg\"); nothing # hide\n\n(Image: )\n\nnote: Note\nBy default, spectra are normalized according to the number of scans and receiver gain determined automatically from the spectrum metadata; this can be disabled with the normalize=false option\n\ntip: Tip\nLegends are produced from the first line of the spectrum title file. The legend can be disabled using the legend=nothing option. To re-label a spectrum, use label!(spectrum, \"new label\") (or for a list of experiments, the i-th spectrum can be relabelled with label!(spectra[i], \"new label\")).\n\nStacked views can also be produced using the vstack=true option. By default, spectra are normalized according to the number of scans and receiver gain determined automatically from the spectrum metadata\n\nplot(spectra, xlims=(-125, -122), vstack=true, legend=:topright)\nsavefig(\"plot-19F-stack.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-plotrecipes/#Plotting-2D-spectra","page":"Plotting","title":"Plotting 2D spectra","text":"2D spectra can be loaded and plotted in the same way as for 1D experiments:\n\n# load a bruker experiment\n# spec2d = loadnmr(\"exampledata/2D_HN/1\")\nspec2d = exampledata(\"2D_HN\")\nplot(spec2d)\nsavefig(\"plot-2D.svg\"); nothing # hide\n\n(Image: )\n\nAs for 1Ds, plots are titled using the label generated when the data are loaded. Positive and negative contour levels are generated starting from five times the noise level.\n\nThe most convenient way to adjust the contour levels is simply to multiply or divide the spectrum by a scaling factor - the noise level stored within the spectrum metadata is not updated and so the contour levels will change accordingly.\n\nThe plot colour can also be modified, by specifying e.g. c=:purple in the plot command. The hue of the requested colour will be used to generate two shades, for positive and negative contours.\n\nplot(spec2d/3, c=:purple, xlims=(6,10))\nsavefig(\"plot-2D-purple.svg\"); nothing # hide\n\n(Image: )\n\nSpectra can also be plotted in other formats, e.g. heatmaps:\n\nheatmap(spec2d[8 .. 8.5, 120 .. 125] / spec2d[:noise], cbar=:right, cbtitle=\"SNR\")\nsavefig(\"plot-2D-heatmap.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-plotrecipes/#Overlaying-multiple-2D-spectra","page":"Plotting","title":"Overlaying multiple 2D spectra","text":"Multiple 2D experiments can conveniently be loaded from a list of filenames using the map function.\n\n# create a list of nmrPipe-processed experiments\nfilenames = [\"../../exampledata/2D_HN_titration/1/test.ft2\",\n             \"../../exampledata/2D_HN_titration/2/test.ft2\",\n             \"../../exampledata/2D_HN_titration/3/test.ft2\",\n             \"../../exampledata/2D_HN_titration/4/test.ft2\",\n             \"../../exampledata/2D_HN_titration/5/test.ft2\",\n             \"../../exampledata/2D_HN_titration/6/test.ft2\",\n             \"../../exampledata/2D_HN_titration/7/test.ft2\",\n             \"../../exampledata/2D_HN_titration/8/test.ft2\",\n             \"../../exampledata/2D_HN_titration/9/test.ft2\",\n             \"../../exampledata/2D_HN_titration/10/test.ft2\",\n             \"../../exampledata/2D_HN_titration/11/test.ft2\"]\nspectra2d = map(loadnmr, filenames)\n\nAs for 1D experiments, these can be plotted, with automatic normalisation for varying numbers of scans and receiver gain, simply by passing the list of spectra to the plot function:\n\nspectra2d = exampledata(\"2D_HN_titration\"); # hide\nplot(spectra2d, legend=:topleft)\nsavefig(\"plot-2D-titration.svg\"); nothing # hide\n\n(Image: )\n\nA gradient of colours will automatically be generated when spectra are plotted in this way, and a legend generated from spectrum labels.\n\nAs usual, plot limits can be adjusted with the xlims and ylims options:\n\nplot(spectra2d[[1,6]], xlims=(8,8.5),ylims=(120,125))\nsavefig(\"plot-2D-lims.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-plotrecipes/#Normalization","page":"Plotting","title":"Normalization","text":"Normalization controls how spectra are scaled when plotted, ensuring fair comparisons between experiments acquired with different parameters. Normalization primarily makes a difference when plotting multiple spectra together. For single spectra, the normalization factor only affects the absolute y-axis values, not the appearance of the plot.\n\nFor 1D spectra, the normalize keyword argument controls automatic scaling:\n\nplot(..., normalize=true) (default): Spectra are normalized according to the number of scans and receiver gain, calculated internally via the scale command. If concentration metadata is available, it will also be included in the normalization.\nplot(..., normalize=false): Each spectrum is plotted with its raw intensity values, without any automatic scaling adjustments.\n\nFor 2D spectra, normalization affects both the intensity scaling and the contour level calculation:\n\nplot(..., normalize=true) (default): Spectra are normalized by the scale factor (accounting for number of scans and receiver gain), and contour levels are set to 5× the noise level. When plotting multiple spectra together, contour levels will be set based on 5× the noise level of the first spectrum, ensuring consistent contour spacing across all spectra in the series.\nplot(..., normalize=false): Each spectrum is plotted individually with contour levels relative to its own noise level (5× noise). This can result in different contour spacing between spectra in a series.\nplot(..., normalize=reference_spectrum): All spectra are scaled to match the reference spectrum. Contour levels are set based on the reference spectrum's noise level. The reference spectrum does not need to be included in the plot itself, which can be useful for creating animations with consistent scaling across frames.\n\ntip: Tip\nIt is usually easiest to plot a series of 2D spectra by passing a list of spectra in a single plot call, rather than adding them to a plot one-by-one using the plot! command. Alternatively, a reference spectrum should be specified to ensure consistent normalization.\n\nExample: Using a reference spectrum for normalization\n\n# Load a series of 2D spectra\nspectra2d = exampledata(\"2D_HN_titration\")\n\n# Plot spectra 2-5, but normalize to spectrum 1\nplot(spectra2d[2:5], normalize=spectra2d[1])","category":"section"},{"location":"tutorial-plotrecipes/#Plotting-pseudo-2D-data","page":"Plotting","title":"Plotting pseudo-2D data","text":"Plot recipes are available for pseudo-2D data like diffusion, relaxation or kinetics.\n\n# load a diffusion measurement, processed in topspin using xf2\ndiffusiondata = exampledata(\"pseudo2D_XSTE\")\n\n# set the gradient strengths - which varied from 2% to 98% of the max, over 10 points\ndiffusiondata = setgradientlist(diffusiondata, LinRange(0.02, 0.98, 10))\n\n# generate a 3D plot of the data\nplot(diffusiondata, xlims=(6,10))\nsavefig(\"plot-diff-3D.svg\"); nothing # hide\n\n(Image: )\n\nBy default, the plot command will generate a 3D plot for pseudo-2D experiments. Heatmaps can also be generated using the heatmap command. In this example, we have selected the range to plot directly, rather than using the xlims option.\n\nheatmap(diffusiondata[7..9,:])\nsavefig(\"plot-diff-heatmap.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"tutorial-plotrecipes/#Saving-plots","page":"Plotting","title":"Saving plots","text":"All plots can be saved as high quality vector graphics, or as png files, using the savefig command.\n\nsavefig(\"myspectrum.pdf\")\nsavefig(\"myspectrum.svd\")\nsavefig(\"myspectrum.png\")","category":"section"},{"location":"metadata-timeunits/#Times-and-frequencies","page":"Times and frequencies","title":"Times and frequencies","text":"For maximum consistency, in NMRTools all time and frequency data are stored as seconds and Hz. This includes:\n\npulse lengths\ndelays\nvdlists and vplists\nspectrometer frequencies (bf, sf)","category":"section"},{"location":"metadata-timeunits/#Examples","page":"Times and frequencies","title":"Examples","text":"using NMRTools # hide\nspec = exampledata(\"2D_HN\") # hide\n@info \"Pulse length p1, in s\" acqus(spec, :p, 1)\n\n@info \"Delay d1, in s\" acqus(spec, :d, 1)\n\n@info \"Base frequency for channel 1, in Hz\" spec[1, :bf]","category":"section"},{"location":"metadata-power/#Power-levels","page":"Power levels","title":"Power levels","text":"Power levels from acquisition parameters are represented using the Power type, which handles both Watts (W) and dB attenuation units with automatic conversion.","category":"section"},{"location":"metadata-power/#Creating-Power-objects","page":"Power levels","title":"Creating Power objects","text":"Power values must be created with an explicit unit specification:\n\n# From dB attenuation\np1 = Power(30.0, :dB)\n\n# From Watts\np2 = Power(0.001, :W)\n\n# Works with any numeric type\np3 = Power(20, :dB)\n\nnote: Note\nCalling Power(value) without a unit will throw an error.","category":"section"},{"location":"metadata-power/#Accessing-from-acqus-data","page":"Power levels","title":"Accessing from acqus data","text":"Power levels are automatically parsed when loading data:\n\nspec = loadnmr(\"experiment\")\n\n# Get power level (returns Power object)\np = acqus(spec, :pl, 1)  # First power level","category":"section"},{"location":"metadata-power/#Accessing-values","page":"Power levels","title":"Accessing values","text":"Use db() and watts() to retrieve values in either unit:\n\np = Power(20.0, :dB)\n\ndb(p)     # 20.0 (dB)\nwatts(p)  # 0.01 (W)\n\nConversion formulas:\n\nmathrmdB = -10 log_10(mathrmwatts)\n\nmathrmwatts = 10^-mathrmdB10","category":"section"},{"location":"metadata-power/#Zero-power-handling","page":"Power levels","title":"Zero power handling","text":"Zero watts is handled specially to avoid logarithm issues:\n\np_zero = Power(0.0, :W)\ndb(p_zero)     # 120.0 (very high attenuation)\nwatts(p_zero)  # ≈ 1e-12\n\nThis is relevant when parsing acqus files where unused power levels may be zero.","category":"section"},{"location":"metadata-power/#Converting-to-RF-field-strength","page":"Power levels","title":"Converting to RF field strength","text":"The hz() function converts power to radiofrequency field strength in Hz using calibration data.","category":"section"},{"location":"metadata-power/#Using-a-reference-RF-strength","page":"Power levels","title":"Using a reference RF strength","text":"# Known calibration: 25 kHz at 30 dB\nref_power = Power(30.0, :dB)\nref_hz = 25000.0\n\n# Calculate RF at different power\ntest_power = Power(36.0, :dB)\nrf = hz(test_power, ref_power, ref_hz)\n\nConversion formula:\n\nmathrmHz = mathrmHz_ref times 10^-DeltamathrmdB20\n\nwhere DeltamathrmdB = mathrmdB - mathrmdB_ref.","category":"section"},{"location":"metadata-power/#Using-pulse-calibration","page":"Power levels","title":"Using pulse calibration","text":"# Known: 10 μs pulse gives 90° at 30 dB\nref_power = Power(30.0, :dB)\npulse_length = 10.0    # μs\nflip_angle = 90.0      # degrees\n\n# Calculate RF at different power\ntest_power = Power(33.0, :dB)\nrf = hz(test_power, ref_power, pulse_length, flip_angle)\n\nThis first calculates the reference RF strength:\n\nmathrmHz_ref = fractheta360 times t\n\nwhere theta is the flip angle (degrees) and t is the pulse length (seconds), then applies the power scaling formula above.","category":"section"},{"location":"#NMRTools.jl","page":"Home","title":"NMRTools.jl","text":"NMRTools.jl is a Julia library for working with NMR spectroscopy data. It provides a simple interface for importing and handling 1D, 2D, and higher-dimensional datasets.\n\nMulti-format support: Read Bruker, nmrPipe and UCSF/Sparky formatted data\nIntuitive data access: Array-like indexing with chemical shift values using spec[8.0 .. 9.0] syntax\nBuilt-in plotting: Publication-quality plots with sensible defaults via Plots.jl recipes\nMetadata handling: Easily access acquisition parameters from Bruker acqus files\nWindow functions: Access and analyse apodization functions used for acquisition\nDimensionalData.jl integration: Leverage powerful array indexing with named dimensions to work seamlessly with frequency, time, and gradient dimensions","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install NMRTools.jl through the Julia package manager:\n\nusing Pkg\nPkg.add(\"NMRTools\")\n\nLoad and plot a spectrum:\n\nusing NMRTools, Plots\nspec = loadnmr(\"path/to/experiment\")\nplot(spec)\n\nSee the Getting started guide for more examples, or explore the tutorial pages for detailed workflows including relaxation analysis, diffusion experiments, and advanced plotting techniques.\n\nnote: Note\nThis package is under active development and it may be a while before its features and syntax stabilises.","category":"section"},{"location":"ref-metadata/#Metadata","page":"Metadata","title":"Metadata","text":"NMRData objects can store various metadata associated with the spectrum and each of the dimensions.\n\nMetadata are stored as dictionaries using symbols as keys (e.g. :ns). They can be accessed using the metadata function, or directly from an NMRData object using a dictionary-style lookup. Metadata associated with axes are accessed by providing an additional reference, either as a dimension number or type (e.g. F1Dim, F2Dim etc.).\n\nmetadata(nmrdata, key) # spectrum metadata\nnmrdata[key]\n\nmetadata(nmrdata, dimension, key) # axis metadata\nnmrdata[dimension, key]","category":"section"},{"location":"ref-metadata/#Labels","page":"Metadata","title":"Labels","text":"","category":"section"},{"location":"ref-metadata/#Acquisition-data","page":"Metadata","title":"Acquisition data","text":"When spectra are loaded, the contents of the acqus file  are parsed (as are the acqu2s files etc. too, if present). These can be accessed with :acqus and :acqu2s keys, etc. For convenience though, the additional function acqus is provided to access acquisiton data directly.","category":"section"},{"location":"ref-metadata/#Auxilliary-files","page":"Metadata","title":"Auxilliary files","text":"acqus can also be used to access the contents of auxilliary files (and if not present, nothing will be returned). Note that NMRTools will perform automatic unit conversion as follows:\n\n:vclist: variable loopcounter\n:vdlist: variable delays, in seconds\n:valist: variable amplitude, in dB (converted from Watts if necessary)\n:vplist: variable pulse lengths, in seconds\n:fq1list up to :fq8list: frequency lists – see the Frequency lists page for more information.","category":"section"},{"location":"ref-metadata/#Frequency-list-API","page":"Metadata","title":"Frequency list API","text":"Frequency lists can be specified on the spectrometer in a number of ways - in Hz, in ppm, and relative to the spectrometer frequency or the base frequency (0 ppm). Frequency lists are therefore stored in NMRTools as FQList structures which encode this additional information.\n\nRaw numerical data can be accessed using the data() function, but it is recommended to use ppm and hz functions to access frequency data safely. See the Frequency lists page for detailed examples.","category":"section"},{"location":"ref-metadata/#Standard-metadata:-spectra","page":"Metadata","title":"Standard metadata: spectra","text":"Key Description\n:acqusfilename path to acqus file\n:acqus contents of acqus file, as a dictionary\n:acqu2s, :acqu3s contents of acqu2s/acqu3s files (if present)\n:experimentfolder path to experiment\n:filename spectrum filename\n:format input file format (:nmrpipe or :pdata)\n:label short label (first line of title pdata file)\n:ndim number of dimensions\n:noise RMS noise level (see estimatenoise!)\n:ns number of scans\n:pulseprogram pulse program title\n:rg receiver gain\n:title spectrum title (contents of title pdata file)\n:topspin Topspin version used for acquisition","category":"section"},{"location":"ref-metadata/#Standard-metadata:-frequency-dimensions","page":"Metadata","title":"Standard metadata: frequency dimensions","text":"Key Description\n:aq acquisition time, in seconds\n:bf base frequency, in Hz\n:label short label\n:npoints final number of real data points in dimension (after extraction)\n:offsethz carrier offset from bf, in Hz\n:offsetppm carrier offset from bf, in ppm\n:pseudodim flag indicating non-frequency domain data (false for frequency domain)\n:region extracted region, expressed as a range in points, otherwise missing\n:sf carrier frequency, in Hz\n:swhz spectrum width, in Hz\n:swppm spectrum width, in ppm\n:td number of complex points acquired, including LP\n:tdzf number of complex points when FT executed, including LP and ZF\n:window WindowFunction encoding applied apodization\n:referenceoffset applied referencing, in ppm","category":"section"},{"location":"ref-metadata/#DimensionalData.Dimensions.Lookups.metadata-ref-metadata","page":"Metadata","title":"DimensionalData.Dimensions.Lookups.metadata","text":"metadata(nmrdata, key)\nmetadata(nmrdata, dim, key)\nmetadata(nmrdimension, key)\n\nReturn the metadata for specified key, or nothing if not found. Keys are passed as symbols.\n\nExamples (spectrum metadata)\n\n:ns: number of scans\n:ds: number of dummy scans\n:rg: receiver gain\n:ndim: number of dimensions\n:title: spectrum title (contents of title pdata file)\n:filename: spectrum filename\n:pulseprogram: title of pulse program used for acquisition\n:experimentfolder: path to experiment\n:noise: RMS noise level\n\nExamples (dimension metadata)\n\n:pseudodim: flag indicating non-frequency domain data\n:npoints: final number of (real) data points in dimension (after extraction)\n:td: number of complex points acquired\n:tdzf: number of complex points when FT executed, including LP and ZF\n:bf: base frequency, in Hz\n:sf: carrier frequency, in Hz\n:offsethz: carrier offset from bf, in Hz\n:offsetppm: carrier offset from bf, in ppm\n:swhz: spectrum width, in Hz\n:swppm: spectrum width, in ppm\n:region: extracted region, expressed as a range in points, otherwise missing\n:window: WindowFunction indicating applied apodization\n:referenceoffset: referencing (in ppm) applied to the dimension\n\nSee also estimatenoise!.\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#DimensionalData.Dimensions.label-ref-metadata","page":"Metadata","title":"DimensionalData.Dimensions.label","text":"label(nmrdata)\nlabel(nmrdata, dim)\nlabel(nmrdimension)\n\nReturn a short label associated with an NMRData structure or an NMRDimension. By default, for a spectrum this is obtained from the first line of the title file. For a frequency dimension, this is normally something of the form 1H chemical shift (ppm).\n\nSee also label!.\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#NMRTools.NMRBase.label!-ref-metadata","page":"Metadata","title":"NMRTools.NMRBase.label!","text":"label!(nmrdata, labeltext)\nlabel!(nmrdata, dim, labeltext)\nlabel!(nmrdimension, labeltext)\n\nSet the label associated with an NMRData structure or an NMRDimension.\n\nSee also label.\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#DimensionalData.Dimensions.Lookups.units-ref-metadata","page":"Metadata","title":"DimensionalData.Dimensions.Lookups.units","text":"units(nmrdata)\nunits(nmrdata, dim)\nunits(nmrdimension)\n\nReturn the physical units associated with an NMRData structure or an NMRDimension.\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#NMRTools.NMRBase.acqus-ref-metadata","page":"Metadata","title":"NMRTools.NMRBase.acqus","text":"acqus(nmrdata)\nacqus(nmrdata, key)\nacqus(nmrdata, key, index)\n\nReturn data from a Bruker acqus file, or nothing if it does not exist. Keys can be passed as symbols or strings. If no key is specified, a dictionary is returned representing the entire acqus file.\n\nIf present, the contents of auxilliary files such as vclist and vdlist can be accessed using this function.\n\nExamples\n\njulia> acqus(expt, :pulprog)\n\"zgesgp\"\njulia> acqus(expt, \"TE\")\n276.9988\njulia> acqus(expt, :p, 1)\n9.2\njulia> acqus(expt, \"D\", 1)\n0.1\njulia> acqus(expt, :vclist)\n11-element Vector{Int64}:\n[...]\n\nSee also metadata.\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#NMRTools.NMRIO.FQList-ref-metadata","page":"Metadata","title":"NMRTools.NMRIO.FQList","text":"FQList(values, unit::Symbol, relative::Bool)\n\nRepresents a frequency list. unit can be :Hz or :ppm, and relative indicates whether the frequency is given relative to SFO (true) or BF (false).\n\nRaw values can be extracted using the data function, or (better) as absolute chemical shifts (in ppm) or relative offsets (in Hz) using ppm and hz functions.\n\nSee also: ppm, hz.\n\n\n\n\n\n","category":"type"},{"location":"ref-metadata/#NMRTools.NMRBase.ppm-ref-metadata","page":"Metadata","title":"NMRTools.NMRBase.ppm","text":"ppm(axis)\n\nReturn the ppm values for points along a frequency axis.\n\n\n\n\n\nppm(offset, axis)\n\nReturn the chemical shifts for a given offset or list of offsets along a frequency axis.\n\n\n\n\n\nppm(f::FQList, ax::FrequencyDimension)\n\nReturn frequency list values in ppm (in absolute terms, i.e. relative to 0 ppm).\n\nSee also: hz\n\n\n\n\n\n","category":"function"},{"location":"ref-metadata/#NMRTools.NMRBase.hz-ref-metadata","page":"Metadata","title":"NMRTools.NMRBase.hz","text":"hz(p::Power, ref_p::Power, ref_Hz)\n\nConvert power to radiofrequency strength in Hz using a reference power and known Hz value.\n\nUses the relationship: Hz = ref_Hz * 10^(-ΔdB/20) where ΔdB is the power difference.\n\nArguments\n\np::Power: Power to convert\nref_p::Power: Reference power with known Hz value\nref_Hz: Radiofrequency strength in Hz at the reference power\n\nReturns\n\nRadiofrequency strength in Hz for power p\n\n\n\n\n\nhz(p::Power, ref_p::Power, ref_pulselength, ref_pulseangle_deg)\n\nConvert power to radiofrequency strength in Hz using reference pulse parameters.\n\nArguments\n\np::Power: Power to convert\nref_p::Power: Reference power\nref_pulselength: Reference pulse length in microseconds\nref_pulseangle_deg: Reference pulse flip angle in degrees\n\nReturns\n\nRadiofrequency strength in Hz for power p\n\n\n\n\n\nhz(axis)\n\nReturn the offsets (in Hz) for points along a frequency axis.\n\n\n\n\n\nhz(δ, axis)\n\nReturn the offset (in Hz) for a chemical shift (or list of shifts) on a frequency axis.\n\n\n\n\n\nhz(f::FQList, ax::FrequencyDimension)\n\nReturn frequency list values as offsets relative to the spectrometer frequency, in Hz.\n\nSee also: ppm\n\n\n\n\n\n","category":"function"},{"location":"ref-coherences/#Coherences-and-isotope-data","page":"Coherences and isotope data","title":"Coherences and isotope data","text":"NMRTools defines commonly used nuclei and provides a framework for identifying single- and multiple-quantum coherences associated with them. Reference data on their gyromagnetic ratios, and spin quantum numbers, is also defined and accessible through simple functions.","category":"section"},{"location":"ref-coherences/#Nuclei","page":"Coherences and isotope data","title":"Nuclei","text":"","category":"section"},{"location":"ref-coherences/#Coherences","page":"Coherences and isotope data","title":"Coherences","text":"","category":"section"},{"location":"ref-coherences/#Reference-data","page":"Coherences and isotope data","title":"Reference data","text":"","category":"section"},{"location":"ref-coherences/#NMRTools.NMRBase.Nucleus-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.Nucleus","text":"Nucleus\n\nEnumeration of common nuclei associated with biomolecular NMR. Nuclei are named e.g. H1, C13.\n\nDefined nuclei: H1, H2, C12, C13, N14, N15, F19, P31.\n\nSee also spin, gyromagneticratio, Coherence.\n\n\n\n\n\n","category":"type"},{"location":"ref-coherences/#NMRTools.NMRBase.Coherence-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.Coherence","text":"Coherence\n\nAbstract supertype for representing coherences.\n\nSee also SQ, MQ.\n\n\n\n\n\n","category":"type"},{"location":"ref-coherences/#NMRTools.NMRBase.SQ-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.SQ","text":"SQ(nucleus::Nucleus, label==\"\")\n\nRepresentation of a single quantum coherence on a given nucleus.\n\nSee also Nucleus, MQ.\n\n\n\n\n\n","category":"type"},{"location":"ref-coherences/#NMRTools.NMRBase.MQ-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.MQ","text":"MQ(coherences, label==\"\")\n\nRepresentation of a multiple-quantum coherence. Coherences are specified as a tuple of tuples, of the form (nucleus, coherenceorder)\n\nExamples\n\njulia> MQ(((H1,1), (C13,-1)), \"ZQ\")\nMQ(((H1, 1), (C13, -1)), \"ZQ\")\n\njulia> MQ(((H1,3), (C13,1)), \"QQ\")\nMQ(((H1, 3), (C13, 1)), \"QQ\")\n\nSee also Nucleus, SQ.\n\n\n\n\n\n","category":"type"},{"location":"ref-coherences/#NMRTools.NMRBase.coherenceorder-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.coherenceorder","text":"coherenceorder(coherence)\n\nCalculate the total coherence order.\n\nExamples\n\njulia> coherenceorder(SQ(H1))\n1\n\njulia> coherenceorder(MQ(((H1,1),(C13,1))))\n2\n\njulia> coherenceorder(MQ(((H1,1),(C13,-1))))\n0\n\njulia> coherenceorder(MQ(((H1,3),(C13,1))))\n4\n\njulia> coherenceorder(MQ(((H1,0),)))\n0\n\nSee also Nucleus, SQ, MQ.\n\n\n\n\n\n","category":"function"},{"location":"ref-coherences/#NMRTools.NMRBase.spin-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.spin","text":"spin(n::Nucleus)\n\nReturn the spin quantum number of nucleus n, or nothing if not defined.\n\nExamples\n\njulia> spin(H1)\n1//2\n\nSee also Coherence.\n\n\n\n\n\n","category":"function"},{"location":"ref-coherences/#NMRTools.NMRBase.gyromagneticratio-ref-coherences","page":"Coherences and isotope data","title":"NMRTools.NMRBase.gyromagneticratio","text":"gyromagneticratio(n::Nucleus)\ngyromagneticratio(c::Coherence)\n\nReturn the gyromagnetic ratio in Hz/T of a nucleus, or calculate the effective gyromagnetic ratio of a coherence. This is equal to the product of the individual gyromagnetic ratios with their coherence orders.\n\nReturns nothing if not defined.\n\nExamples\n\njulia> gyromagneticratio(H1)\n2.6752218744e8\n\njulia> gyromagneticratio(SQ(H1))\n2.6752218744e8\n\njulia> gyromagneticratio(MQ(((H1,1),(C13,1))))\n3.3480498744e8\n\njulia> gyromagneticratio(MQ(((H1,0),)))\n0.0\n\nSee also Nucleus, Coherence.\n\n\n\n\n\n","category":"function"}]
}
